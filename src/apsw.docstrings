/* This file is generated by rst2docstring */

#ifndef __GNUC__
#define __builtin_types_compatible_p(x,y) (1)
#endif

#define  Apsw_allow_missing_dict_bindings_DOC "allow_missing_dict_bindings($self,value)\n--\n\napsw.allow_missing_dict_bindings(value: bool) -> bool\n\n" \
"Changes how missing bindings are handled when using a :class:`dict`.\n" \
"Historically missing bindings were treated as *None*.  It was\n" \
"anticipated that dict bindings would be used when there were lots\n" \
"of columns, so having missing ones defaulting to *None* was\n" \
"convenient.\n" \
"\n" \
"Unfortunately this also has the side effect of not catching typos\n" \
"and similar issues.\n" \
"\n" \
"APSW 3.41.0.0 changed the default so that missing dict entries\n" \
"will result in an exception.  Call this with *True* to restore\n" \
"the earlier behaviour, and *False* to have an exception.\n" \
"\n" \
"The previous value is returned.\n" 

#define Apsw_allow_missing_dict_bindings_value_MSG  "argument 'value' of apsw.allow_missing_dict_bindings(value: bool) -> bool" 

#define Apsw_allow_missing_dict_bindings_USAGE "apsw.allow_missing_dict_bindings(value: bool) -> bool"

#define Apsw_allow_missing_dict_bindings_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(value), int)); \
} while(0)


#define  Apsw_apswversion_DOC "apswversion($self)\n--\n\napsw.apswversion() -> str\n\n" \
"Returns the APSW version.\n" 

#define  Apsw_complete_DOC "complete($self,statement)\n--\n\napsw.complete(statement: str) -> bool\n\n" \
"Returns True if the input string comprises one or more complete SQL\n" \
"statements by looking for an unquoted trailing semi-colon.\n" \
"\n" \
"An example use would be if you were prompting the user for SQL\n" \
"statements and needed to know if you had a whole statement, or\n" \
"needed to ask for another line::\n" \
"\n" \
"  statement = input(\"SQL> \")\n" \
"  while not apsw.complete(statement):\n" \
"     more = input(\"  .. \")\n" \
"     statement = statement + \"\\n\" + more\n" \
"\n" \
"Calls: `sqlite3_complete <https://sqlite.org/c3ref/complete.html>`__\n" 

#define Apsw_complete_USAGE "apsw.complete(statement: str) -> bool"

#define Apsw_complete_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statement), const char *)); \
} while(0)


#define  Apsw_config_DOC "config($self,op,*args)\n--\n\napsw.config(op: int, *args: Any) -> None\n\n" \
":param op: A `configuration operation <https://sqlite.org/c3ref/c_config_chunkalloc.html>`_\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
"Many operations don't make sense from a Python program.  The\n" \
"following configuration operations are supported: SQLITE_CONFIG_LOG,\n" \
"SQLITE_CONFIG_SINGLETHREAD, SQLITE_CONFIG_MULTITHREAD,\n" \
"SQLITE_CONFIG_SERIALIZED, SQLITE_CONFIG_URI, SQLITE_CONFIG_MEMSTATUS,\n" \
"SQLITE_CONFIG_COVERING_INDEX_SCAN, SQLITE_CONFIG_PCACHE_HDRSZ,\n" \
"SQLITE_CONFIG_PMASZ, and SQLITE_CONFIG_STMTJRNL_SPILL.\n" \
"\n" \
"See :ref:`tips <diagnostics_tips>` for an example of how to receive\n" \
"log messages (SQLITE_CONFIG_LOG)\n" \
"\n" \
"Calls: `sqlite3_config <https://sqlite.org/c3ref/config.html>`__\n" 

#define  Apsw_connections_DOC "connections($self)\n--\n\napsw.connections() -> list[Connection]\n\n" \
"Returns a list of the connections\n" 

#define  Apsw_enablesharedcache_DOC "enablesharedcache($self,enable)\n--\n\napsw.enablesharedcache(enable: bool) -> None\n\n" \
"If you use the same :class:`Connection` across threads or use\n" \
"multiple :class:`connections <Connection>` accessing the same file,\n" \
"then SQLite can `share the cache between them\n" \
"<https://sqlite.org/sharedcache.html>`_.  It is :ref:`not\n" \
"recommended <sharedcache>` that you use this.\n" \
"\n" \
"Calls: `sqlite3_enable_shared_cache <https://sqlite.org/c3ref/enable_shared_cache.html>`__\n" 

#define Apsw_enablesharedcache_enable_MSG  "argument 'enable' of apsw.enablesharedcache(enable: bool) -> None" 

#define Apsw_enablesharedcache_USAGE "apsw.enablesharedcache(enable: bool) -> None"

#define Apsw_enablesharedcache_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(enable), int)); \
} while(0)


#define  Apsw_exceptionfor_DOC "exceptionfor($self,code)\n--\n\napsw.exceptionfor(code: int) -> Exception\n\n" \
"If you would like to raise an exception that corresponds to a\n" \
"particular SQLite `error code\n" \
"<https://sqlite.org/c3ref/c_abort.html>`_ then call this function.\n" \
"It also understands `extended error codes\n" \
"<https://sqlite.org/c3ref/c_ioerr_access.html>`_.\n" \
"\n" \
"For example to raise `SQLITE_IOERR_ACCESS <https://sqlite.org/c3ref/c_ioerr_access.html>`_::\n" \
"\n" \
"  raise apsw.exceptionfor(apsw.SQLITE_IOERR_ACCESS)\n" 

#define Apsw_exceptionfor_USAGE "apsw.exceptionfor(code: int) -> Exception"

#define Apsw_exceptionfor_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(code), int)); \
} while(0)


#define  Apsw_fork_checker_DOC "fork_checker($self)\n--\n\napsw.fork_checker() -> None\n\n" \
"**Note** This method is not available on Windows as it does not\n" \
"support the fork system call.\n" \
"\n" \
"SQLite does not allow the use of database connections across `forked\n" \
"<http://en.wikipedia.org/wiki/Fork_(operating_system)>`__ processes\n" \
"(see the `SQLite FAQ Q6 <https://sqlite.org/faq.html#q6>`__).\n" \
"(Forking creates a child process that is a duplicate of the parent\n" \
"including the state of all data structures in the program.  If you\n" \
"do this to SQLite then parent and child would both consider\n" \
"themselves owners of open databases and silently corrupt each\n" \
"other's work and interfere with each other's locks.)\n" \
"\n" \
"One example of how you may end up using fork is if you use the\n" \
"`multiprocessing module\n" \
"<http://docs.python.org/library/multiprocessing.html>`__ which uses\n" \
"fork to make child processes.\n" \
"\n" \
"If you do use fork or multiprocessing on a platform that supports\n" \
"fork then you **must** ensure database connections and their objects\n" \
"(cursors, backup, blobs etc) are not used in the parent process, or\n" \
"are all closed before calling fork or starting a `Process\n" \
"<http://docs.python.org/library/multiprocessing.html#process-and-exceptions>`__.\n" \
"(Note you must call close to ensure the underlying SQLite objects\n" \
"are closed.  It is also a good idea to call `gc.collect(2)\n" \
"<http://docs.python.org/library/gc.html#gc.collect>`__ to ensure\n" \
"anything you may have missed is also deallocated.)\n" \
"\n" \
"Once you run this method, extra checking code is inserted into\n" \
"SQLite's mutex operations (at a very small performance penalty) that\n" \
"verifies objects are not used across processes.  You will get a\n" \
":exc:`ForkingViolationError` if you do so.  Note that due to the way\n" \
"Python's internals work, the exception will be delivered to\n" \
"`sys.excepthook` in addition to the normal exception mechanisms and\n" \
"may be reported by Python after the line where the issue actually\n" \
"arose.  (Destructors of objects you didn't close also run between\n" \
"lines.)\n" \
"\n" \
"You should only call this method as the first line after importing\n" \
"APSW, as it has to shutdown and re-initialize SQLite.  If you have\n" \
"any SQLite objects already allocated when calling the method then\n" \
"the program will later crash.  The recommended use is to use the fork\n" \
"checking as part of your test suite.\n" 

#define  Apsw_format_sql_value_DOC "format_sql_value($self,value)\n--\n\napsw.format_sql_value(value: SQLiteValue) -> str\n\n" \
"Returns a Python string representing the supplied value in SQLite\n" \
"syntax.\n" \
"\n" \
"Note that SQLite represents floating point `Nan\n" \
"<https://en.wikipedia.org/wiki/NaN>`__ as :code:`NULL`, infinity as\n" \
":code:`1e999` and loses the sign on `negative zero\n" \
"<https://en.wikipedia.org/wiki/Signed_zero>`__.\n" 

#define  Apsw_hard_heap_limit_DOC "hard_heap_limit($self,limit)\n--\n\napsw.hard_heap_limit(limit: int) -> int\n\n" \
"Enforces SQLite keeping memory usage below *limit* bytes and\n" \
"returns the previous limit.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    :meth:`softheaplimit`\n" \
"\n" \
"Calls: `sqlite3_hard_heap_limit64 <https://sqlite.org/c3ref/hard_heap_limit64.html>`__\n" 

#define Apsw_hard_heap_limit_USAGE "apsw.hard_heap_limit(limit: int) -> int"

#define Apsw_hard_heap_limit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(limit), long long)); \
} while(0)


#define  Apsw_initialize_DOC "initialize($self)\n--\n\napsw.initialize() -> None\n\n" \
"It is unlikely you will want to call this method as SQLite automatically initializes.\n" \
"\n" \
"Calls: `sqlite3_initialize <https://sqlite.org/c3ref/initialize.html>`__\n" 

#define  Apsw_log_DOC "log($self,errorcode,message)\n--\n\napsw.log(errorcode: int, message: str) -> None\n\n" \
"Calls the SQLite logging interface.  Note that you must format the\n" \
"message before passing it to this method::\n" \
"\n" \
"    apsw.log(apsw.SQLITE_NOMEM, f\"Need { needed } bytes of memory\")\n" \
"\n" \
"See :ref:`tips <diagnostics_tips>` for an example of how to\n" \
"receive log messages.\n" \
"\n" \
"Calls: `sqlite3_log <https://sqlite.org/c3ref/log.html>`__\n" 

#define Apsw_log_USAGE "apsw.log(errorcode: int, message: str) -> None"

#define Apsw_log_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(errorcode), int)); \
  assert(__builtin_types_compatible_p(typeof(message), const char *)); \
} while(0)


#define  Apsw_memoryhighwater_DOC "memoryhighwater($self,reset=False)\n--\n\napsw.memoryhighwater(reset: bool = False) -> int\n\n" \
"Returns the maximum amount of memory SQLite has used.  If *reset* is\n" \
"True then the high water mark is reset to the current value.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`status`\n" \
"\n" \
"Calls: `sqlite3_memory_highwater <https://sqlite.org/c3ref/memory_highwater.html>`__\n" 

#define Apsw_memoryhighwater_reset_MSG  "argument 'reset' of apsw.memoryhighwater(reset: bool = False) -> int" 

#define Apsw_memoryhighwater_USAGE "apsw.memoryhighwater(reset: bool = False) -> int"

#define Apsw_memoryhighwater_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Apsw_memoryused_DOC "memoryused($self)\n--\n\napsw.memoryused() -> int\n\n" \
"Returns the amount of memory SQLite is currently using.\n" \
"\n" \
".. seealso::\n" \
"  :meth:`status`\n" \
"\n" \
"\n" \
"Calls: `sqlite3_memory_used <https://sqlite.org/c3ref/memory_highwater.html>`__\n" 

#define  Apsw_no_change_DOC "A sentinel value used to indicate no change in a value when\n" \
"used with :meth:`VTCursor.ColumnNoChange` and\n" \
":meth:`VTTable.UpdateChangeRow`\n" 

#define  Apsw_randomness_DOC "randomness($self,amount)\n--\n\napsw.randomness(amount: int)  -> bytes\n\n" \
"Gets random data from SQLite's random number generator.\n" \
"\n" \
":param amount: How many bytes to return\n" \
"\n" \
"Calls: `sqlite3_randomness <https://sqlite.org/c3ref/randomness.html>`__\n" 

#define Apsw_randomness_USAGE "apsw.randomness(amount: int)  -> bytes"

#define Apsw_randomness_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define  Apsw_releasememory_DOC "releasememory($self,amount)\n--\n\napsw.releasememory(amount: int) -> int\n\n" \
"Requests SQLite try to free *amount* bytes of memory.  Returns how\n" \
"many bytes were freed.\n" \
"\n" \
"Calls: `sqlite3_release_memory <https://sqlite.org/c3ref/release_memory.html>`__\n" 

#define Apsw_releasememory_USAGE "apsw.releasememory(amount: int) -> int"

#define Apsw_releasememory_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define  Apsw_set_default_vfs_DOC "set_default_vfs($self,name)\n--\n\napsw.set_default_vfs(name: str) -> None\n\n" \
"Sets the default vfs to *name* which must be an existing vfs.\n" \
"See :meth:`vfsnames`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_register <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define Apsw_set_default_vfs_USAGE "apsw.set_default_vfs(name: str) -> None"

#define Apsw_set_default_vfs_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Apsw_shutdown_DOC "shutdown($self)\n--\n\napsw.shutdown() -> None\n\n" \
"It is unlikely you will want to call this method and there is no\n" \
"need to do so.  It is a **really** bad idea to call it unless you\n" \
"are absolutely sure all :class:`connections <Connection>`,\n" \
":class:`blobs <Blob>`, :class:`cursors <Cursor>`, :class:`vfs <VFS>`\n" \
"etc have been closed, deleted and garbage collected.\n" \
"\n" \
"Calls: `sqlite3_shutdown <https://sqlite.org/c3ref/initialize.html>`__\n" 

#define  Apsw_softheaplimit_DOC "softheaplimit($self,limit)\n--\n\napsw.softheaplimit(limit: int) -> int\n\n" \
"Requests SQLite try to keep memory usage below *limit* bytes and\n" \
"returns the previous limit.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    :meth:`hard_heap_limit`\n" \
"\n" \
"Calls: `sqlite3_soft_heap_limit64 <https://sqlite.org/c3ref/hard_heap_limit64.html>`__\n" 

#define Apsw_softheaplimit_USAGE "apsw.softheaplimit(limit: int) -> int"

#define Apsw_softheaplimit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(limit), long long)); \
} while(0)


#define  Apsw_sqlite3_sourceid_DOC "sqlite3_sourceid($self)\n--\n\napsw.sqlite3_sourceid() -> str\n\n" \
"Returns the exact checkin information for the SQLite 3 source\n" \
"being used.\n" \
"\n" \
"Calls: `sqlite3_sourceid <https://sqlite.org/c3ref/libversion.html>`__\n" 

#define  Apsw_sqlitelibversion_DOC "sqlitelibversion($self)\n--\n\napsw.sqlitelibversion() -> str\n\n" \
"Returns the version of the SQLite library.  This value is queried at\n" \
"run time from the library so if you use shared libraries it will be\n" \
"the version in the shared library.\n" \
"\n" \
"Calls: `sqlite3_libversion <https://sqlite.org/c3ref/libversion.html>`__\n" 

#define  Apsw_status_DOC "status($self,op,reset=False)\n--\n\napsw.status(op: int, reset: bool = False) -> Tuple[int, int]\n\n" \
"Returns current and highwater measurements.\n" \
"\n" \
":param op: A `status parameter <https://sqlite.org/c3ref/c_status_malloc_size.html>`_\n" \
":param reset: If *True* then the highwater is set to the current value\n" \
":returns: A tuple of current value and highwater value\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Status example <example_status>`\n" \
"\n" \
"Calls: `sqlite3_status64 <https://sqlite.org/c3ref/status.html>`__\n" 

#define Apsw_status_reset_MSG  "argument 'reset' of apsw.status(op: int, reset: bool = False) -> Tuple[int, int]" 

#define Apsw_status_USAGE "apsw.status(op: int, reset: bool = False) -> Tuple[int, int]"

#define Apsw_status_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Apsw_strglob_DOC "strglob($self,glob,string)\n--\n\napsw.strglob(glob: str, string: str) -> int\n\n" \
"Does string GLOB matching.  Note that zero is returned on on a match.\n" \
"\n" \
"Calls: `sqlite3_strglob <https://sqlite.org/c3ref/strglob.html>`__\n" 

#define Apsw_strglob_USAGE "apsw.strglob(glob: str, string: str) -> int"

#define Apsw_strglob_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(glob), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string), const char *)); \
} while(0)


#define  Apsw_stricmp_DOC "stricmp($self,string1,string2)\n--\n\napsw.stricmp(string1: str, string2: str) -> int\n\n" \
"Does string case-insensitive comparison.  Note that zero is returned\n" \
"on on a match.\n" \
"\n" \
"Calls: `sqlite3_stricmp <https://sqlite.org/c3ref/stricmp.html>`__\n" 

#define Apsw_stricmp_USAGE "apsw.stricmp(string1: str, string2: str) -> int"

#define Apsw_stricmp_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(string1), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string2), const char *)); \
} while(0)


#define  Apsw_strlike_DOC "strlike($self,glob,string,escape=0)\n--\n\napsw.strlike(glob: str, string: str, escape: int = 0) -> int\n\n" \
"Does string LIKE matching.  Note that zero is returned on on a match.\n" \
"\n" \
"Calls: `sqlite3_strlike <https://sqlite.org/c3ref/strlike.html>`__\n" 

#define Apsw_strlike_USAGE "apsw.strlike(glob: str, string: str, escape: int = 0) -> int"

#define Apsw_strlike_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(glob), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string), const char *)); \
  assert(__builtin_types_compatible_p(typeof(escape), int)); \
  assert(escape == (0)); \
} while(0)


#define  Apsw_strnicmp_DOC "strnicmp($self,string1,string2,count)\n--\n\napsw.strnicmp(string1: str, string2: str, count: int) -> int\n\n" \
"Does string case-insensitive comparison.  Note that zero is returned\n" \
"on on a match.\n" \
"\n" \
"Calls: `sqlite3_strnicmp <https://sqlite.org/c3ref/stricmp.html>`__\n" 

#define Apsw_strnicmp_USAGE "apsw.strnicmp(string1: str, string2: str, count: int) -> int"

#define Apsw_strnicmp_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(string1), const char *)); \
  assert(__builtin_types_compatible_p(typeof(string2), const char *)); \
  assert(__builtin_types_compatible_p(typeof(count), int)); \
} while(0)


#define  Apsw_unregister_vfs_DOC "unregister_vfs($self,name)\n--\n\napsw.unregister_vfs(name: str) -> None\n\n" \
"Unregisters the named vfs.  See :meth:`vfsnames`.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_unregister <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define Apsw_unregister_vfs_USAGE "apsw.unregister_vfs(name: str) -> None"

#define Apsw_unregister_vfs_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Apsw_vfsnames_DOC "vfsnames($self)\n--\n\napsw.vfsnames() -> List[str]\n\n" \
"Returns a list of the currently installed :ref:`vfs <vfs>`.  The first\n" \
"item in the list is the default vfs.\n" 

#define  Backup_class_DOC "You create a backup instance by calling :meth:`Connection.backup`.\n" 

#define  Backup_close_DOC "close($self,force=False)\n--\n\nBackup.close(force: bool = False) -> None\n\n" \
"Does the same thing as :meth:`~Backup.finish`.  This extra api is\n" \
"provided to give the same api as other APSW objects such as\n" \
":meth:`Connection.close`, :meth:`Blob.close` and\n" \
":meth:`Cursor.close`.  It is safe to call this method multiple\n" \
"times.\n" \
"\n" \
":param force: If true then any exceptions are ignored.\n" 

#define Backup_close_force_MSG  "argument 'force' of Backup.close(force: bool = False) -> None" 

#define Backup_close_USAGE "Backup.close(force: bool = False) -> None"

#define Backup_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Backup_done_DOC ":type: bool\n" \
"\n" \
"A boolean that is True if the copy completed in the last call to :meth:`~Backup.step`.\n" 

#define  Backup_enter_DOC "__enter__($self)\n--\n\nBackup.__enter__() -> Backup\n\n" \
"You can use the backup object as a `context manager\n" \
"<http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  The :meth:`~Backup.__exit__` method ensures that backup\n" \
"is :meth:`finished <Backup.finish>`.\n" 

#define  Backup_exit_DOC "__exit__($self,etype,evalue,etraceback)\n--\n\nBackup.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]\n\n" \
"Implements context manager in conjunction with :meth:`~Backup.__enter__` ensuring\n" \
"that the copy is :meth:`finished <Backup.finish>`.\n" 

#define Backup_exit_USAGE "Backup.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]"

#define Backup_exit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(etype), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(evalue), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(etraceback), PyObject *)); \
} while(0)


#define  Backup_finish_DOC "finish($self)\n--\n\nBackup.finish() -> None\n\n" \
"Completes the copy process.  If all pages have been copied then the\n" \
"transaction is committed on the destination database, otherwise it\n" \
"is rolled back.  This method must be called for your backup to take\n" \
"effect.  The backup object will always be finished even if there is\n" \
"an exception.  It is safe to call this method multiple times.\n" \
"\n" \
"Calls: `sqlite3_backup_finish <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupfinish>`__\n" 

#define  Backup_pagecount_DOC ":type: int\n" \
"\n" \
"Read only. How many pages were in the source database after the last\n" \
"step.  If you haven't called :meth:`~Backup.step` or the backup\n" \
"object has been :meth:`finished <Backup.finish>` then zero is\n" \
"returned.\n" \
"\n" \
"Calls: `sqlite3_backup_pagecount <https://sqlite.org/c3ref/backup_finish.html#sqlite3backuppagecount>`__\n" 

#define  Backup_remaining_DOC ":type: int\n" \
"\n" \
"Read only. How many pages were remaining to be copied after the last\n" \
"step.  If you haven't called :meth:`~Backup.step` or the backup\n" \
"object has been :meth:`finished <Backup.finish>` then zero is\n" \
"returned.\n" \
"\n" \
"Calls: `sqlite3_backup_remaining <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupremaining>`__\n" 

#define  Backup_step_DOC "step($self,npages=-1)\n--\n\nBackup.step(npages: int = -1) -> bool\n\n" \
"Copies *npages* pages from the source to destination database.  The source database is locked during the copy so\n" \
"using smaller values allows other access to the source database.  The destination database is always locked until the\n" \
"backup object is :meth:`finished <Backup.finish>`.\n" \
"\n" \
":param npages: How many pages to copy. If the parameter is omitted\n" \
"   or negative then all remaining pages are copied. The default page\n" \
"   size is 1024 bytes (1kb) which can be changed before database\n" \
"   creation using a `pragma\n" \
"   <https://sqlite.org/pragma.html#modify>`_.\n" \
"\n" \
"This method may throw a :exc:`BusyError` or :exc:`LockedError` if\n" \
"unable to lock the source database.  You can catch those and try\n" \
"again.\n" \
"\n" \
":returns: True if this copied the last remaining outstanding pages, else false.  This is the same value as :attr:`~Backup.done`\n" \
"\n" \
"Calls: `sqlite3_backup_step <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupstep>`__\n" 

#define Backup_step_USAGE "Backup.step(npages: int = -1) -> bool"

#define Backup_step_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(npages), int)); \
  assert(npages == (-1)); \
} while(0)


#define  Blob_class_DOC "This object is created by :meth:`Connection.blobopen` and provides\n" \
"access to a blob in the database.  It behaves like a Python file.\n" \
"At the C level it wraps a `sqlite3_blob\n" \
"<https://sqlite.org/c3ref/blob.html>`_.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You cannot change the size of a blob using this object. You should\n" \
"  create it with the correct size in advance either by using\n" \
"  :class:`zeroblob` or the `zeroblob()\n" \
"  <https://sqlite.org/lang_corefunc.html>`_ function.\n" \
"\n" \
"See the :ref:`example <example_blob_io>`.\n" 

#define  Blob_close_DOC "close($self,force=False)\n--\n\nBlob.close(force: bool = False) -> None\n\n" \
"Closes the blob.  Note that even if an error occurs the blob is\n" \
"still closed.\n" \
"\n" \
".. note::\n" \
"\n" \
"   In some cases errors that technically occurred in the\n" \
"   :meth:`~Blob.read` and :meth:`~Blob.write` routines may not be\n" \
"   reported until close is called.  Similarly errors that occurred\n" \
"   in those methods (eg calling :meth:`~Blob.write` on a read-only\n" \
"   blob) may also be re-reported in :meth:`~Blob.close`.  (This\n" \
"   behaviour is what the underlying SQLite APIs do - it is not APSW\n" \
"   doing it.)\n" \
"\n" \
"It is okay to call :meth:`~Blob.close` multiple times.\n" \
"\n" \
":param force: Ignores any errors during close.\n" \
"\n" \
"Calls: `sqlite3_blob_close <https://sqlite.org/c3ref/blob_close.html>`__\n" 

#define Blob_close_force_MSG  "argument 'force' of Blob.close(force: bool = False) -> None" 

#define Blob_close_USAGE "Blob.close(force: bool = False) -> None"

#define Blob_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Blob_enter_DOC "__enter__($self)\n--\n\nBlob.__enter__() -> Blob\n\n" \
"You can use a blob as a `context manager\n" \
"<http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  When you use *with* statement,\n" \
"the blob is always :meth:`closed <Blob.close>` on exit from the block, even if an\n" \
"exception occurred in the block.\n" \
"\n" \
"For example::\n" \
"\n" \
"  with connection.blobopen() as blob:\n" \
"      blob.write(\"...\")\n" \
"      res=blob.read(1024)\n" 

#define  Blob_exit_DOC "__exit__($self,etype,evalue,etraceback)\n--\n\nBlob.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]\n\n" \
"Implements context manager in conjunction with\n" \
":meth:`~Blob.__enter__`.  Any exception that happened in the\n" \
"*with* block is raised after closing the blob.\n" 

#define  Blob_length_DOC "length($self)\n--\n\nBlob.length() -> int\n\n" \
"Returns the size of the blob in bytes.\n" \
"\n" \
"Calls: `sqlite3_blob_bytes <https://sqlite.org/c3ref/blob_bytes.html>`__\n" 

#define  Blob_read_DOC "read($self,length=-1)\n--\n\nBlob.read(length: int = -1) -> bytes\n\n" \
"Reads amount of data requested, or till end of file, whichever is\n" \
"earlier. Attempting to read beyond the end of the blob returns an\n" \
"empty bytes in the same manner as end of file on normal file\n" \
"objects.  Negative numbers read remaining data.\n" \
"\n" \
"Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__\n" 

#define Blob_read_USAGE "Blob.read(length: int = -1) -> bytes"

#define Blob_read_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(length), int)); \
  assert(length == (-1)); \
} while(0)


#define  Blob_readinto_DOC "readinto($self,buffer,offset=0,length=-1)\n--\n\nBlob.readinto(buffer: Union[bytearray, array.array[Any], memoryview], offset: int = 0, length: int = -1) -> None\n\n" \
"Reads from the blob into a buffer you have supplied.  This method is\n" \
"useful if you already have a buffer like object that data is being\n" \
"assembled in, and avoids allocating results in :meth:`Blob.read` and\n" \
"then copying into buffer.\n" \
"\n" \
":param buffer: A writable buffer like object.\n" \
"               There is a :class:`bytearray` type that is very useful.\n" \
"               :mod:`Arrays <array>` also work.\n" \
"\n" \
":param offset: The position to start writing into the buffer\n" \
"               defaulting to the beginning.\n" \
"\n" \
":param length: How much of the blob to read.  The default is the\n" \
"               remaining space left in the buffer.  Note that if\n" \
"               there is more space available than blob left then you\n" \
"               will get a *ValueError* exception.\n" \
"\n" \
"Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__\n" 

#define Blob_readinto_USAGE "Blob.readinto(buffer: Union[bytearray, array.array[Any], memoryview], offset: int = 0, length: int = -1) -> None"

#define Blob_readinto_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(buffer), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
  assert(offset == 0L); \
  assert(__builtin_types_compatible_p(typeof(length), long long)); \
  assert(length == -1L); \
} while(0)


#define  Blob_reopen_DOC "reopen($self,rowid)\n--\n\nBlob.reopen(rowid: int) -> None\n\n" \
"Change this blob object to point to a different row.  It can be\n" \
"faster than closing an existing blob an opening a new one.\n" \
"\n" \
"Calls: `sqlite3_blob_reopen <https://sqlite.org/c3ref/blob_reopen.html>`__\n" 

#define Blob_reopen_USAGE "Blob.reopen(rowid: int) -> None"

#define Blob_reopen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
} while(0)


#define  Blob_seek_DOC "seek($self,offset,whence=0)\n--\n\nBlob.seek(offset: int, whence: int = 0) -> None\n\n" \
"Changes current position to *offset* biased by *whence*.\n" \
"\n" \
":param offset: New position to seek to.  Can be positive or negative number.\n" \
":param whence: Use 0 if *offset* is relative to the beginning of the blob,\n" \
"               1 if *offset* is relative to the current position,\n" \
"               and 2 if *offset* is relative to the end of the blob.\n" \
":raises ValueError: If the resulting offset is before the beginning (less than zero) or beyond the end of the blob.\n" 

#define Blob_seek_USAGE "Blob.seek(offset: int, whence: int = 0) -> None"

#define Blob_seek_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(offset), int)); \
  assert(__builtin_types_compatible_p(typeof(whence), int)); \
  assert(whence == (0)); \
} while(0)


#define  Blob_tell_DOC "tell($self)\n--\n\nBlob.tell() -> int\n\n" \
"Returns the current offset.\n" 

#define  Blob_write_DOC "write($self,data)\n--\n\nBlob.write(data: bytes) -> None\n\n" \
"Writes the data to the blob.\n" \
"\n" \
":param data: bytes to write\n" \
"\n" \
":raises TypeError: Wrong data type\n" \
"\n" \
":raises ValueError: If the data would go beyond the end of the blob.\n" \
"    You cannot increase the size of a blob by writing beyond the end.\n" \
"    You need to use :class:`zeroblob` to set the desired size first when\n" \
"    inserting the blob.\n" \
"\n" \
"Calls: `sqlite3_blob_write <https://sqlite.org/c3ref/blob_write.html>`__\n" 

#define Blob_write_USAGE "Blob.write(data: bytes) -> None"

#define Blob_write_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(data), Py_buffer)); \
} while(0)


#define  Connection_authorizer_DOC ":type: Optional[Authorizer]\n" \
"\n" \
"While `preparing <https://sqlite.org/c3ref/prepare.html>`_\n" \
"statements, SQLite will call any defined authorizer to see if a\n" \
"particular action is ok to be part of the statement.\n" \
"\n" \
"Typical usage would be if you are running user supplied SQL and want\n" \
"to prevent harmful operations.  You should also\n" \
"set the :class:`statementcachesize <Connection>` to zero.\n" \
"\n" \
"The authorizer callback has 5 parameters:\n" \
"\n" \
"  * An `operation code <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string (or None) dependent on the operation `(listed as 3rd) <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string (or None) dependent on the operation `(listed as 4th) <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string name of the database (or None)\n" \
"  * Name of the innermost trigger or view doing the access (or None)\n" \
"\n" \
"The authorizer callback should return one of *SQLITE_OK*,\n" \
"*SQLITE_DENY* or *SQLITE_IGNORE*.\n" \
"(*SQLITE_DENY* is returned if there is an error in your\n" \
"Python code).\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_authorizer>`\n" \
"  * :ref:`statementcache`\n" \
"\n" \
"Calls: `sqlite3_set_authorizer <https://sqlite.org/c3ref/set_authorizer.html>`__\n" 

#define  Connection_autovacuum_pages_DOC "autovacuum_pages($self,callable)\n--\n\nConnection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None\n\n" \
"Calls `callable` to find out how many pages to autovacuum.  The callback has 4 parameters:\n" \
"\n" \
"* Database name: str (eg \"main\")\n" \
"* Database pages: int (how many pages make up the database now)\n" \
"* Free pages: int (how many pages could be freed)\n" \
"* Page size: int (page size in bytes)\n" \
"\n" \
"Return how many pages should be freed.  Values less than zero or more than the free pages are\n" \
"treated as zero or free page count.  On error zero is returned.\n" \
"\n" \
"READ THE NOTE IN THE SQLITE DOCUMENTATION.  Calling into SQLite can result in crashes, corrupt\n" \
"databases or worse.\n" \
"\n" \
"Calls: `sqlite3_autovacuum_pages <https://sqlite.org/c3ref/autovacuum_pages.html>`__\n" 

#define Connection_autovacuum_pages_callable_MSG  "argument 'callable' of Connection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None" 

#define Connection_autovacuum_pages_USAGE "Connection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None"

#define Connection_autovacuum_pages_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_backup_DOC "backup($self,databasename,sourceconnection,sourcedatabasename)\n--\n\nConnection.backup(databasename: str, sourceconnection: Connection, sourcedatabasename: str)  -> Backup\n\n" \
"Opens a :ref:`backup object <Backup>`.  All data will be copied from source\n" \
"database to this database.\n" \
"\n" \
":param databasename: Name of the database.  This will be ``main`` for\n" \
"  the main connection and the name you specified for `attached\n" \
"  <https://sqlite.org/lang_attach.html>`_ databases.\n" \
":param sourceconnection: The :class:`Connection` to copy a database from.\n" \
":param sourcedatabasename: Name of the database in the source (eg ``main``).\n" \
"\n" \
":rtype: :class:`backup`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Backup`\n" \
"\n" \
"Calls: `sqlite3_backup_init <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupinit>`__\n" 

#define Connection_backup_USAGE "Connection.backup(databasename: str, sourceconnection: Connection, sourcedatabasename: str)  -> Backup"

#define Connection_backup_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(databasename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(sourceconnection), Connection *)); \
  assert(__builtin_types_compatible_p(typeof(sourcedatabasename), const char *)); \
} while(0)


#define  Connection_blobopen_DOC "blobopen($self,database,table,column,rowid,writeable)\n--\n\nConnection.blobopen(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob\n\n" \
"Opens a blob for :ref:`incremental I/O <blobio>`.\n" \
"\n" \
":param database: Name of the database.  This will be ``main`` for\n" \
"  the main connection and the name you specified for `attached\n" \
"  <https://sqlite.org/lang_attach.html>`_ databases.\n" \
":param table: The name of the table\n" \
":param column: The name of the column\n" \
":param rowid: The id that uniquely identifies the row.\n" \
":param writeable: If True then you can read and write the blob.  If False then you can only read it.\n" \
"\n" \
":rtype: :class:`Blob`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Blob I/O example <example_blob_io>`\n" \
"  * `SQLite row ids <https://sqlite.org/autoinc.html>`_\n" \
"\n" \
"Calls: `sqlite3_blob_open <https://sqlite.org/c3ref/blob_open.html>`__\n" 

#define Connection_blobopen_writeable_MSG  "argument 'writeable' of Connection.blobopen(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob" 

#define Connection_blobopen_USAGE "Connection.blobopen(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob"

#define Connection_blobopen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(database), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table), const char *)); \
  assert(__builtin_types_compatible_p(typeof(column), const char *)); \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
  assert(__builtin_types_compatible_p(typeof(writeable), int)); \
} while(0)


#define  Connection_cache_stats_DOC "cache_stats($self,include_entries=False)\n--\n\nConnection.cache_stats(include_entries: bool = False) -> Dict[str, int]\n\n" \
"Returns information about the statement cache as dict.\n" \
"\n" \
".. note::\n" \
"\n" \
"  Calling execute with \"select a; select b; insert into c ...\" will\n" \
"  result in 3 cache entries corresponding to each of the 3 queries\n" \
"  present.\n" \
"\n" \
"The returned dictionary has the following information.\n" \
"\n" \
".. list-table::\n" \
"  :header-rows: 1\n" \
"  :widths: auto\n" \
"\n" \
"  * - Key\n" \
"    - Explanation\n" \
"  * - size\n" \
"    - Maximum number of entries in the cache\n" \
"  * - evictions\n" \
"    - How many entries were removed (expired) to make space for a newer\n" \
"      entry\n" \
"  * - no_cache\n" \
"    - Queries that had can_cache parameter set to False\n" \
"  * - hits\n" \
"    - A match was found in the cache\n" \
"  * - misses\n" \
"    - No match was found in the cache, or the cache couldn't be used\n" \
"  * - no_vdbe\n" \
"    - The statement was empty (eg a comment) or SQLite took action\n" \
"      during parsing (eg some pragmas).  These are not cached and also\n" \
"      included in the misses count\n" \
"  * - too_big\n" \
"    - UTF8 query size was larger than considered for caching.  These are also included\n" \
"      in the misses count.\n" \
"  * - max_cacheable_bytes\n" \
"    - Maximum size of query (in bytes of utf8) that will be considered for caching\n" \
"  * - entries\n" \
"    - (Only present if `include_entries` is True) A list of the cache entries\n" \
"\n" \
"If `entries` is present, then each list entry is a dict with the following information.\n" \
"\n" \
".. list-table::\n" \
"  :header-rows: 1\n" \
"  :widths: auto\n" \
"\n" \
"  * - Key\n" \
"    - Explanation\n" \
"  * - query\n" \
"    - Text of the query itself (first statement only)\n" \
"  * - prepare_flags\n" \
"    - Flags passed to `sqlite3_prepare_v3 <https://sqlite.org/c3ref/prepare.html>`__\n" \
"      for this query\n" \
"  * - uses\n" \
"    - How many times this entry has been (re)used\n" \
"  * - has_more\n" \
"    - Boolean indicating if there was more query text than\n" \
"      the first statement\n" 

#define Connection_cache_stats_include_entries_MSG  "argument 'include_entries' of Connection.cache_stats(include_entries: bool = False) -> Dict[str, int]" 

#define Connection_cache_stats_USAGE "Connection.cache_stats(include_entries: bool = False) -> Dict[str, int]"

#define Connection_cache_stats_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(include_entries), int)); \
  assert(include_entries == 0); \
} while(0)


#define  Connection_cacheflush_DOC "cacheflush($self)\n--\n\nConnection.cacheflush() -> None\n\n" \
"Flushes caches to disk mid-transaction.\n" \
"\n" \
"Calls: `sqlite3_db_cacheflush <https://sqlite.org/c3ref/db_cacheflush.html>`__\n" 

#define  Connection_changes_DOC "changes($self)\n--\n\nConnection.changes() -> int\n\n" \
"Returns the number of database rows that were changed (or inserted\n" \
"or deleted) by the most recently completed INSERT, UPDATE, or DELETE\n" \
"statement.\n" \
"\n" \
"Calls: `sqlite3_changes64 <https://sqlite.org/c3ref/changes.html>`__\n" 

#define  Connection_class_DOC "This object wraps a `sqlite3 pointer\n" \
"<https://sqlite.org/c3ref/sqlite3.html>`_.\n" 

#define  Connection_close_DOC "close($self,force=False)\n--\n\nConnection.close(force: bool = False) -> None\n\n" \
"Closes the database.  If there are any outstanding :class:`cursors\n" \
"<Cursor>`, :class:`blobs <Blob>` or :class:`backups <Backup>` then\n" \
"they are closed too.  It is normally not necessary to call this\n" \
"method as the database is automatically closed when there are no\n" \
"more references.  It is ok to call the method multiple times.\n" \
"\n" \
"If your user defined functions or collations have direct or indirect\n" \
"references to the Connection then it won't be automatically garbage\n" \
"collected because of circular referencing that can't be\n" \
"automatically broken.  Calling *close* will free all those objects\n" \
"and what they reference.\n" \
"\n" \
"SQLite is designed to survive power failures at even the most\n" \
"awkward moments.  Consequently it doesn't matter if it is closed\n" \
"when the process is exited, or even if the exit is graceful or\n" \
"abrupt.  In the worst case of having a transaction in progress, that\n" \
"transaction will be rolled back by the next program to open the\n" \
"database, reverting the database to a know good state.\n" \
"\n" \
"If *force* is *True* then any exceptions are ignored.\n" \
"\n" \
"Calls: `sqlite3_close <https://sqlite.org/c3ref/close.html>`__\n" 

#define Connection_close_force_MSG  "argument 'force' of Connection.close(force: bool = False) -> None" 

#define Connection_close_USAGE "Connection.close(force: bool = False) -> None"

#define Connection_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Connection_collationneeded_DOC "collationneeded($self,callable)\n--\n\nConnection.collationneeded(callable: Optional[Callable[[Connection, str], None]]) -> None\n\n" \
"*callable* will be called if a statement requires a `collation\n" \
"<http://en.wikipedia.org/wiki/Collation>`_ that hasn't been\n" \
"registered. Your callable will be passed two parameters. The first\n" \
"is the connection object. The second is the name of the\n" \
"collation. If you have the collation code available then call\n" \
":meth:`Connection.createcollation`.\n" \
"\n" \
"This is useful for creating collations on demand.  For example you\n" \
"may include the `locale <http://en.wikipedia.org/wiki/Locale>`_ in\n" \
"the collation name, but since there are thousands of locales in\n" \
"popular use it would not be useful to :meth:`prereigster\n" \
"<Connection.createcollation>` them all.  Using\n" \
":meth:`~Connection.collationneeded` tells you when you need to\n" \
"register them.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.createcollation`\n" \
"\n" \
"Calls: `sqlite3_collation_needed <https://sqlite.org/c3ref/collation_needed.html>`__\n" 

#define Connection_collationneeded_callable_MSG  "argument 'callable' of Connection.collationneeded(callable: Optional[Callable[[Connection, str], None]]) -> None" 

#define Connection_collationneeded_USAGE "Connection.collationneeded(callable: Optional[Callable[[Connection, str], None]]) -> None"

#define Connection_collationneeded_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_column_metadata_DOC "column_metadata($self,dbname,table_name,column_name)\n--\n\nConnection.column_metadata(dbname: Optional[str], table_name: str, column_name: str) -> Tuple[str, str, bool, bool, bool]\n\n" \
"`dbname` is the specific database (eg \"main\", \"temp\") or None to search\n" \
"all databases.\n" \
"\n" \
"The returned :class:`tuple` has these fields:\n" \
"\n" \
"0: str - declared data type\n" \
"\n" \
"1: str - name of default collation sequence\n" \
"\n" \
"2: bool - True if not null constraint\n" \
"\n" \
"3: bool - True if part of primary key\n" \
"\n" \
"4: bool - True if column is `autoincrement <https://www.sqlite.org/autoinc.html>`__\n" \
"\n" \
"Calls: `sqlite3_table_column_metadata <https://sqlite.org/c3ref/table_column_metadata.html>`__\n" 

#define Connection_column_metadata_USAGE "Connection.column_metadata(dbname: Optional[str], table_name: str, column_name: str) -> Tuple[str, str, bool, bool, bool]"

#define Connection_column_metadata_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table_name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(column_name), const char *)); \
} while(0)


#define  Connection_config_DOC "config($self,op,*args)\n--\n\nConnection.config(op: int, *args: int) -> int\n\n" \
":param op: A `configuration operation\n" \
"  <https://sqlite.org/c3ref/c_dbconfig_enable_fkey.html>`__\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
"Only optiona that take an int and return one are implemented.\n" \
"\n" \
"Calls: `sqlite3_db_config <https://sqlite.org/c3ref/db_config.html>`__\n" 

#define  Connection_create_window_function_DOC "create_window_function($self,name,factory,numargs=-1,*,flags=0)\n--\n\nConnection.create_window_function(name:str, factory: Optional[WindowFactory], numargs: int =-1, *, flags: int = 0) -> None\n\n" \
"Registers a `window function\n" \
"<https://sqlite.org/windowfunctions.html#user_defined_aggregate_window_functions>`__\n" \
"\n" \
"  :param name: The string name of the function.  It should be less than 255 characters\n" \
"  :param factory: Called to start a new window.  Use None to delete the function.\n" \
"  :param numargs: How many arguments the function takes, with -1 meaning any number\n" \
"  :param flags: `Function flags <https://www.sqlite.org/c3ref/c_deterministic.html>`__\n" \
"\n" \
"You need to provide callbacks for the ``step``, ``final``, ``value``\n" \
"and ``inverse`` methods.  This can be done by having `factory` as a\n" \
"class, and the corresponding method names, or by having `factory`\n" \
"return a sequence of a first parameter, and then each of the 4\n" \
"functions.\n" \
"\n" \
"**Debugging note** SQlite always calls the ``final`` method to allow\n" \
"for cleanup.  If you have an error in one of the other methods, then\n" \
"``final`` will also be called, and you may see both methods in\n" \
"tracebacks.\n" \
"\n" \
".. seealso::\n" \
"\n" \
" * :ref:`Example <example_window>`\n" \
" * :meth:`~Connection.createaggregatefunction`\n" \
"\n" \
"Calls: `sqlite3_create_window_function <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_create_window_function_factory_MSG  "argument 'factory' of Connection.create_window_function(name:str, factory: Optional[WindowFactory], numargs: int =-1, *, flags: int = 0) -> None" 

#define Connection_create_window_function_USAGE "Connection.create_window_function(name:str, factory: Optional[WindowFactory], numargs: int =-1, *, flags: int = 0) -> None"

#define Connection_create_window_function_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(factory), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define  Connection_createaggregatefunction_DOC "createaggregatefunction($self,name,factory,numargs=-1,*,flags=0)\n--\n\nConnection.createaggregatefunction(name: str, factory: Optional[AggregateFactory], numargs: int = -1, *, flags: int = 0) -> None\n\n" \
"Registers an aggregate function.  Aggregate functions operate on all\n" \
"the relevant rows such as counting how many there are.\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param factory: The function that will be called.  Use None to delete the function.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
":param flags: `Function flags <https://www.sqlite.org/c3ref/c_deterministic.html>`__\n" \
"\n" \
"When a query starts, the *factory* will be called and must return a tuple of 3 items:\n" \
"\n" \
"  a context object\n" \
"     This can be of any type\n" \
"\n" \
"  a step function\n" \
"     This function is called once for each row.  The first parameter\n" \
"     will be the context object and the remaining parameters will be\n" \
"     from the SQL statement.  Any value returned will be ignored.\n" \
"\n" \
"  a final function\n" \
"     This function is called at the very end with the context object\n" \
"     as a parameter.  The value returned is set as the return for\n" \
"     the function. The final function is always called even if an\n" \
"     exception was raised by the step function. This allows you to\n" \
"     ensure any resources are cleaned up.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You can register the same named function but with different\n" \
"  callables and *numargs*.  See\n" \
"  :meth:`~Connection.createscalarfunction` for an example.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_aggregate>`\n" \
"   * :meth:`~Connection.createscalarfunction`\n" \
"\n" \
"Calls: `sqlite3_create_function_v2 <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_createaggregatefunction_factory_MSG  "argument 'factory' of Connection.createaggregatefunction(name: str, factory: Optional[AggregateFactory], numargs: int = -1, *, flags: int = 0) -> None" 

#define Connection_createaggregatefunction_USAGE "Connection.createaggregatefunction(name: str, factory: Optional[AggregateFactory], numargs: int = -1, *, flags: int = 0) -> None"

#define Connection_createaggregatefunction_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(factory), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define  Connection_createcollation_DOC "createcollation($self,name,callback)\n--\n\nConnection.createcollation(name: str, callback: Optional[Callable[[str, str], int]]) -> None\n\n" \
"You can control how SQLite sorts (termed `collation\n" \
"<http://en.wikipedia.org/wiki/Collation>`_) when giving the\n" \
"``COLLATE`` term to a `SELECT\n" \
"<https://sqlite.org/lang_select.html>`_.  For example your\n" \
"collation could take into account locale or do numeric sorting.\n" \
"\n" \
"The *callback* will be called with two items.  It should return -1\n" \
"if the first is less then the second, 0 if they are equal, and 1 if\n" \
"first is greater::\n" \
"\n" \
"   def mycollation(one, two):\n" \
"       if one < two:\n" \
"           return -1\n" \
"       if one == two:\n" \
"           return 0\n" \
"       if one > two:\n" \
"           return 1\n" \
"\n" \
"Passing None as the callback will unregister the collation.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_collation>`\n" \
"\n" \
"Calls: `sqlite3_create_collation_v2 <https://sqlite.org/c3ref/create_collation.html>`__\n" 

#define Connection_createcollation_callback_MSG  "argument 'callback' of Connection.createcollation(name: str, callback: Optional[Callable[[str, str], int]]) -> None" 

#define Connection_createcollation_USAGE "Connection.createcollation(name: str, callback: Optional[Callable[[str, str], int]]) -> None"

#define Connection_createcollation_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
} while(0)


#define  Connection_createmodule_DOC "createmodule($self,name,datasource,*,use_bestindex_object=False,use_no_change=False,iVersion=1,eponymous=False,eponymous_only=False,read_only=False)\n--\n\nConnection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None\n\n" \
"Registers a virtual table, or drops it if *datasource* is *None*.\n" \
"See :ref:`virtualtables` for details.\n" \
"\n" \
":param name: Module name (what comes after USING in CREATE VIRTUAL TABLE tablename USING ...)\n" \
":param datasource: Provides :class:`VTModule` methods\n" \
":param use_bestindex_object: If True then BestIndexObject is used, else BestIndex\n" \
":param use_no_change: Turn on understanding :meth:`VTCursor.ColumnNoChange` and using :attr:`apsw.no_change` to reduce :meth:`VTTable.UpdateChangeRow` work\n" \
":param iVersion: iVersion field in `sqlite3_module <https://www.sqlite.org/c3ref/module.html>`__\n" \
":param eponymous: Configures module to be `eponymous <https://www.sqlite.org/vtab.html#eponymous_virtual_tables>`__\n" \
":param eponymous_only: Configures module to be `eponymous only <https://www.sqlite.org/vtab.html#eponymous_only_virtual_tables>`__\n" \
":param read_only: Leaves `sqlite3_module <https://www.sqlite.org/c3ref/module.html>`__ methods that involve writing and transactions as NULL\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_virtual_tables>`\n" \
"\n" \
"Calls: `sqlite3_create_module_v2 <https://sqlite.org/c3ref/create_module.html>`__\n" 

#define Connection_createmodule_use_bestindex_object_MSG  "argument 'use_bestindex_object' of Connection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None" 
#define Connection_createmodule_use_no_change_MSG  "argument 'use_no_change' of Connection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None" 
#define Connection_createmodule_eponymous_MSG  "argument 'eponymous' of Connection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None" 
#define Connection_createmodule_eponymous_only_MSG  "argument 'eponymous_only' of Connection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None" 
#define Connection_createmodule_read_only_MSG  "argument 'read_only' of Connection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None" 

#define Connection_createmodule_USAGE "Connection.createmodule(name: str, datasource: Optional[VTModule], *, use_bestindex_object: bool = False, use_no_change: bool = False, iVersion: int = 1, eponymous: bool=False, eponymous_only: bool = False, read_only: bool = False) -> None"

#define Connection_createmodule_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(datasource), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(use_bestindex_object), int)); \
  assert(use_bestindex_object == 0); \
  assert(__builtin_types_compatible_p(typeof(use_no_change), int)); \
  assert(use_no_change == 0); \
  assert(__builtin_types_compatible_p(typeof(iVersion), int)); \
  assert(iVersion == (1)); \
  assert(__builtin_types_compatible_p(typeof(eponymous), int)); \
  assert(eponymous == 0); \
  assert(__builtin_types_compatible_p(typeof(eponymous_only), int)); \
  assert(eponymous_only == 0); \
  assert(__builtin_types_compatible_p(typeof(read_only), int)); \
  assert(read_only == 0); \
} while(0)


#define  Connection_createscalarfunction_DOC "createscalarfunction($self,name,callable,numargs=-1,*,deterministic=False,flags=0)\n--\n\nConnection.createscalarfunction(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, *, deterministic: bool = False, flags: int = 0) -> None\n\n" \
"Registers a scalar function.  Scalar functions operate on one set of parameters once.\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param callable: The function that will be called.  Use None to unregister.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
":param deterministic: When True this means the function always\n" \
"         returns the same result for the same input arguments.\n" \
"         SQLite's query planner can perform additional optimisations\n" \
"         for deterministic functions.  For example a random()\n" \
"         function is not deterministic while one that returns the\n" \
"         length of a string is.\n" \
":param flags: Additional `function flags <https://www.sqlite.org/c3ref/c_deterministic.html>`__\n" \
"\n" \
".. note::\n" \
"\n" \
"  You can register the same named function but with different\n" \
"  *callable* and *numargs*.  For example::\n" \
"\n" \
"    connection.createscalarfunction(\"toip\", ipv4convert, 4)\n" \
"    connection.createscalarfunction(\"toip\", ipv6convert, 16)\n" \
"    connection.createscalarfunction(\"toip\", strconvert, -1)\n" \
"\n" \
"  The one with the correct *numargs* will be called and only if that\n" \
"  doesn't exist then the one with negative *numargs* will be called.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_scalar>`\n" \
"   * :meth:`~Connection.createaggregatefunction`\n" \
"\n" \
"Calls: `sqlite3_create_function_v2 <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_createscalarfunction_callable_MSG  "argument 'callable' of Connection.createscalarfunction(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, *, deterministic: bool = False, flags: int = 0) -> None" 
#define Connection_createscalarfunction_deterministic_MSG  "argument 'deterministic' of Connection.createscalarfunction(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, *, deterministic: bool = False, flags: int = 0) -> None" 

#define Connection_createscalarfunction_USAGE "Connection.createscalarfunction(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, *, deterministic: bool = False, flags: int = 0) -> None"

#define Connection_createscalarfunction_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(deterministic), int)); \
  assert(deterministic == 0); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (0)); \
} while(0)


#define  Connection_cursor_DOC "cursor($self)\n--\n\nConnection.cursor() -> Cursor\n\n" \
"Creates a new :class:`Cursor` object on this database.\n" \
"\n" \
":rtype: :class:`Cursor`\n" 

#define  Connection_cursor_factory_DOC ":type: Callable[[Connection], Any]\n" \
"\n" \
"Defaults to :class:`Cursor`\n" \
"\n" \
"Called with a :class:`Connection` as the only parameter when a cursor\n" \
"is needed such as by the :meth:`cursor` method, or\n" \
":meth:`Connection.execute`.\n" \
"\n" \
"Note that whatever is returned doesn't have to be an actual\n" \
":class:`Cursor` instance, and just needs to have the methods present\n" \
"that are actually called.  These are likely to be `execute`,\n" \
"`executemany`, `close` etc.\n" 

#define  Connection_db_filename_DOC "db_filename($self,name)\n--\n\nConnection.db_filename(name: str) -> str\n\n" \
"Returns the full filename of the named (attached) database.  The\n" \
"main database is named \"main\".\n" \
"\n" \
"Calls: `sqlite3_db_filename <https://sqlite.org/c3ref/db_filename.html>`__\n" 

#define Connection_db_filename_USAGE "Connection.db_filename(name: str) -> str"

#define Connection_db_filename_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_db_names_DOC "db_names($self)\n--\n\nConnection.db_names() -> List[str]\n\n" \
"Returns the list of database names.  For example the first database\n" \
"is named 'main', the next 'temp', and the rest with the name provided\n" \
"in `ATTACH <https://www.sqlite.org/lang_attach.html>`__\n" \
"\n" \
"Calls: `sqlite3_db_name <https://sqlite.org/c3ref/db_name.html>`__\n" 

#define  Connection_deserialize_DOC "deserialize($self,name,contents)\n--\n\nConnection.deserialize(name: str, contents: bytes) -> None\n\n" \
"Replaces the named database with an in-memory copy of *contents*.\n" \
"*name* is **\"main\"** for the main database, **\"temp\"** for the\n" \
"temporary database etc.\n" \
"\n" \
"The resulting database is in-memory, read-write, and the memory is\n" \
"owned, resized, and freed by SQLite.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.serialize`\n" \
"\n" \
"Calls: `sqlite3_deserialize <https://sqlite.org/c3ref/deserialize.html>`__\n" 

#define Connection_deserialize_USAGE "Connection.deserialize(name: str, contents: bytes) -> None"

#define Connection_deserialize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(contents), Py_buffer)); \
} while(0)


#define  Connection_drop_modules_DOC "drop_modules($self,keep)\n--\n\nConnection.drop_modules(keep: Optional[Sequence[str]]) -> None\n\n" \
"If *keep* is *None* then all registered virtual tables are dropped.\n" \
"\n" \
"Otherwise *keep* is a sequence of strings, naming the virtual tables that\n" \
"are kept, dropping all others.\n" 

#define Connection_drop_modules_USAGE "Connection.drop_modules(keep: Optional[Sequence[str]]) -> None"

#define Connection_drop_modules_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(keep), PyObject *)); \
} while(0)


#define  Connection_enableloadextension_DOC "enableloadextension($self,enable)\n--\n\nConnection.enableloadextension(enable: bool) -> None\n\n" \
"Enables/disables `extension loading\n" \
"<https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_\n" \
"which is disabled by default.\n" \
"\n" \
":param enable: If True then extension loading is enabled, else it is disabled.\n" \
"\n" \
"Calls: `sqlite3_enable_load_extension <https://sqlite.org/c3ref/enable_load_extension.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.loadextension`\n" 

#define Connection_enableloadextension_enable_MSG  "argument 'enable' of Connection.enableloadextension(enable: bool) -> None" 

#define Connection_enableloadextension_USAGE "Connection.enableloadextension(enable: bool) -> None"

#define Connection_enableloadextension_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(enable), int)); \
} while(0)


#define  Connection_enter_DOC "__enter__($self)\n--\n\nConnection.__enter__() -> Connection\n\n" \
"You can use the database as a `context manager\n" \
"<http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  When you use *with* a transaction is\n" \
"started.  If the block finishes with an exception then the\n" \
"transaction is rolled back, otherwise it is committed.  For example::\n" \
"\n" \
"  with connection:\n" \
"      connection.execute(\"....\")\n" \
"      with connection:\n" \
"          # nested is supported\n" \
"          call_function(connection)\n" \
"          connection.execute(\"...\")\n" \
"          with connection as db:\n" \
"              # You can also use 'as'\n" \
"              call_function2(db)\n" \
"              db.execute(\"...\")\n" \
"\n" \
"Behind the scenes the `savepoint\n" \
"<https://sqlite.org/lang_savepoint.html>`_ functionality introduced in\n" \
"SQLite 3.6.8 is used to provide nested transactions.\n" 

#define  Connection_exectrace_DOC ":type: Optional[ExecTracer]\n" \
"\n" \
"Called with the cursor, statement and bindings for\n" \
"each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this\n" \
"Connection, unless the :class:`Cursor` installed its own\n" \
"tracer. Your execution tracer can also abort execution of a\n" \
"statement.\n" \
"\n" \
"If *callable* is *None* then any existing execution tracer is\n" \
"removed.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :attr:`Cursor.exectrace`\n" 

#define  Connection_execute_DOC "execute($self,statements,bindings=None,*,can_cache=True,prepare_flags=0)\n--\n\nConnection.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor\n\n" \
"Executes the statements using the supplied bindings.  Execution\n" \
"returns when the first row is available or all statements have\n" \
"completed.  (A cursor is automatically obtained).\n" \
"\n" \
"See :meth:`Cursor.execute` for more details.\n" 

#define  Connection_executemany_DOC "executemany($self,statements,sequenceofbindings,*,can_cache=True,prepare_flags=0)\n--\n\nConnection.executemany(statements: str, sequenceofbindings:Sequence[Bindings], *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor\n\n" \
"This method is for when you want to execute the same statements over a\n" \
"sequence of bindings, such as inserting into a database.  (A cursor is\n" \
"automatically obtained).\n" \
"\n" \
"See :meth:`Cursor.executemany` for more details.\n" 

#define  Connection_exit_DOC "__exit__($self,etype,evalue,etraceback)\n--\n\nConnection.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]\n\n" \
"Implements context manager in conjunction with\n" \
":meth:`~Connection.__enter__`.  Any exception that happened in the\n" \
"*with* block is raised after committing or rolling back the\n" \
"savepoint.\n" 

#define Connection_exit_USAGE "Connection.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[types.TracebackType]) -> Optional[bool]"

#define Connection_exit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(etype), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(evalue), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(etraceback), PyObject *)); \
} while(0)


#define  Connection_filecontrol_DOC "filecontrol($self,dbname,op,pointer)\n--\n\nConnection.filecontrol(dbname: str, op: int, pointer: int) -> bool\n\n" \
"Calls the :meth:`~VFSFile.xFileControl` method on the :ref:`VFS`\n" \
"implementing :class:`file access <VFSFile>` for the database.\n" \
"\n" \
":param dbname: The name of the database to affect (eg \"main\", \"temp\", attached name)\n" \
":param op: A `numeric code\n" \
"  <https://sqlite.org/c3ref/c_fcntl_lockstate.html>`_ with values less\n" \
"  than 100 reserved for SQLite internal use.\n" \
":param pointer: A number which is treated as a ``void pointer`` at the C level.\n" \
"\n" \
":returns: True or False indicating if the VFS understood the op.\n" \
"\n" \
"If you want data returned back then the *pointer* needs to point to\n" \
"something mutable.  Here is an example using `ctypes\n" \
"<https://docs.python.org/3/library/ctypes.html>`_ of\n" \
"passing a Python dictionary to :meth:`~VFSFile.xFileControl` which\n" \
"can then modify the dictionary to set return values::\n" \
"\n" \
"  obj={\"foo\": 1, 2: 3}                 # object we want to pass\n" \
"  objwrap=ctypes.py_object(obj)        # objwrap must live before and after the call else\n" \
"                                       # it gets garbage collected\n" \
"  connection.filecontrol(\n" \
"           \"main\",                     # which db\n" \
"           123,                        # our op code\n" \
"           ctypes.addressof(objwrap))  # get pointer\n" \
"\n" \
"The :meth:`~VFSFile.xFileControl` method then looks like this::\n" \
"\n" \
"  def xFileControl(self, op, pointer):\n" \
"      if op==123:                      # our op code\n" \
"          obj=ctypes.py_object.from_address(pointer).value\n" \
"          # play with obj - you can use id() to verify it is the same\n" \
"          print(obj[\"foo\"])\n" \
"          obj[\"result\"]=\"it worked\"\n" \
"          return True\n" \
"      else:\n" \
"          # pass to parent/superclass\n" \
"          return super(MyFile, self).xFileControl(op, pointer)\n" \
"\n" \
"This is how you set the chunk size by which the database grows.  Do\n" \
"not combine it into one line as the c_int would be garbage collected\n" \
"before the filecontrol call is made::\n" \
"\n" \
"   chunksize=ctypes.c_int(32768)\n" \
"   connection.filecontrol(\"main\", apsw.SQLITE_FCNTL_CHUNK_SIZE, ctypes.addressof(chunksize))\n" \
"\n" \
"Calls: `sqlite3_file_control <https://sqlite.org/c3ref/file_control.html>`__\n" 

#define Connection_filecontrol_pointer_MSG  "argument 'pointer' of Connection.filecontrol(dbname: str, op: int, pointer: int) -> bool" 

#define Connection_filecontrol_USAGE "Connection.filecontrol(dbname: str, op: int, pointer: int) -> bool"

#define Connection_filecontrol_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define  Connection_filename_DOC ":type: str\n" \
"\n" \
"The filename of the database.\n" \
"\n" \
"Calls: `sqlite3_db_filename <https://sqlite.org/c3ref/db_filename.html>`__\n" 

#define  Connection_filename_journal_DOC ":type: str\n" \
"\n" \
"The journal filename of the database,\n" \
"\n" \
"Calls: `sqlite3_filename_journal <https://sqlite.org/c3ref/filename_database.html>`__\n" 

#define  Connection_filename_wal_DOC ":type: str\n" \
"\n" \
"The WAL filename of the database,\n" \
"\n" \
"Calls: `sqlite3_filename_wal <https://sqlite.org/c3ref/filename_database.html>`__\n" 

#define  Connection_getautocommit_DOC "getautocommit($self)\n--\n\nConnection.getautocommit() -> bool\n\n" \
"Returns if the Connection is in auto commit mode (ie not in a transaction).\n" \
"\n" \
"Calls: `sqlite3_get_autocommit <https://sqlite.org/c3ref/get_autocommit.html>`__\n" 

#define  Connection_getexectrace_DOC "getexectrace($self)\n--\n\nConnection.getexectrace() -> Optional[ExecTracer]\n\n" \
"Returns the currently installed :attr:`execution tracer\n" \
"<Connection.exectrace>`\n" 

#define  Connection_getrowtrace_DOC "getrowtrace($self)\n--\n\nConnection.getrowtrace() -> Optional[RowTracer]\n\n" \
"Returns the currently installed :attr:`row tracer\n" \
"<Connection.rowtrace>`\n" 

#define  Connection_in_transaction_DOC ":type: bool\n" \
"\n" \
"True if currently in a transaction, else False\n" \
"\n" \
"Calls: `sqlite3_get_autocommit <https://sqlite.org/c3ref/get_autocommit.html>`__\n" 

#define  Connection_init_DOC "__init__($self,filename,flags=SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,vfs=None,statementcachesize=100)\n--\n\nConnection.__init__(filename: str, flags: int = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs: Optional[str] = None, statementcachesize: int = 100)\n\n" \
"Opens the named database.  You can use ``:memory:`` to get a private temporary\n" \
"in-memory database that is not shared with any other connections.\n" \
"\n" \
":param flags: One or more of the `open flags <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ orred together\n" \
":param vfs: The name of the `vfs <https://sqlite.org/c3ref/vfs.html>`_ to use.  If *None* then the default\n" \
"   vfs will be used.\n" \
"\n" \
":param statementcachesize: Use zero to disable the statement cache,\n" \
"  or a number larger than the total distinct SQL statements you\n" \
"  execute frequently.\n" \
"\n" \
"Calls: `sqlite3_open_v2 <https://sqlite.org/c3ref/open.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :attr:`apsw.connection_hooks`\n" \
"  * :ref:`statementcache`\n" \
"  * :ref:`vfs`\n" 

#define Connection_init_USAGE "Connection.__init__(filename: str, flags: int = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs: Optional[str] = None, statementcachesize: int = 100)"

#define Connection_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE)); \
  assert(__builtin_types_compatible_p(typeof(vfs), const char *)); \
  assert(vfs == 0); \
  assert(__builtin_types_compatible_p(typeof(statementcachesize), int)); \
  assert(statementcachesize == (100)); \
} while(0)


#define  Connection_interrupt_DOC "interrupt($self)\n--\n\nConnection.interrupt() -> None\n\n" \
"Causes any pending operations on the database to abort at the\n" \
"earliest opportunity. You can call this from any thread.  For\n" \
"example you may have a long running query when the user presses the\n" \
"stop button in your user interface.  :exc:`InterruptError`\n" \
"will be raised in the query that got interrupted.\n" \
"\n" \
"Calls: `sqlite3_interrupt <https://sqlite.org/c3ref/interrupt.html>`__\n" 

#define  Connection_is_interrupted_DOC ":type: bool\n" \
"\n" \
"Indicates if this connection has been interrupted.\n" \
"\n" \
"Calls: `sqlite3_is_interrupted <https://sqlite.org/c3ref/interrupt.html>`__\n" 

#define  Connection_last_insert_rowid_DOC "last_insert_rowid($self)\n--\n\nConnection.last_insert_rowid() -> int\n\n" \
"Returns the integer key of the most recent insert in the database.\n" \
"\n" \
"Calls: `sqlite3_last_insert_rowid <https://sqlite.org/c3ref/last_insert_rowid.html>`__\n" 

#define  Connection_limit_DOC "limit($self,id,newval=-1)\n--\n\nConnection.limit(id: int, newval: int = -1) -> int\n\n" \
"If called with one parameter then the current limit for that *id* is\n" \
"returned.  If called with two then the limit is set to *newval*.\n" \
"\n" \
"\n" \
":param id: One of the `runtime limit ids <https://sqlite.org/c3ref/c_limit_attached.html>`_\n" \
":param newval: The new limit.  This is a 32 bit signed integer even on 64 bit platforms.\n" \
"\n" \
":returns: The limit in place on entry to the call.\n" \
"\n" \
"Calls: `sqlite3_limit <https://sqlite.org/c3ref/limit.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_limits>`\n" 

#define Connection_limit_USAGE "Connection.limit(id: int, newval: int = -1) -> int"

#define Connection_limit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(id), int)); \
  assert(__builtin_types_compatible_p(typeof(newval), int)); \
  assert(newval == (-1)); \
} while(0)


#define  Connection_loadextension_DOC "loadextension($self,filename,entrypoint=None)\n--\n\nConnection.loadextension(filename: str, entrypoint: Optional[str] = None) -> None\n\n" \
"Loads *filename* as an `extension <https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_\n" \
"\n" \
":param filename: The file to load.  This must be Unicode or Unicode compatible\n" \
"\n" \
":param entrypoint: The initialization method to call.  If this\n" \
"  parameter is not supplied then the SQLite default of\n" \
"  ``sqlite3_extension_init`` is used.\n" \
"\n" \
":raises ExtensionLoadingError: If the extension could not be\n" \
"  loaded.  The exception string includes more details.\n" \
"\n" \
"Calls: `sqlite3_load_extension <https://sqlite.org/c3ref/load_extension.html>`__\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.enableloadextension`\n" 

#define Connection_loadextension_USAGE "Connection.loadextension(filename: str, entrypoint: Optional[str] = None) -> None"

#define Connection_loadextension_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(entrypoint), const char *)); \
  assert(entrypoint == 0); \
} while(0)


#define  Connection_open_flags_DOC ":type: int\n" \
"\n" \
"The integer flags used to open the database.\n" 

#define  Connection_open_vfs_DOC ":type: str\n" \
"\n" \
"The string name of the vfs used to open the database.\n" 

#define  Connection_overloadfunction_DOC "overloadfunction($self,name,nargs)\n--\n\nConnection.overloadfunction(name: str, nargs: int) -> None\n\n" \
"Registers a placeholder function so that a virtual table can provide an implementation via\n" \
":meth:`VTTable.FindFunction`.\n" \
"\n" \
":param name: Function name\n" \
":param nargs: How many arguments the function takes\n" \
"\n" \
"Due to cvstrac 3507 underlying errors will not be returned.\n" \
"\n" \
"Calls: `sqlite3_overload_function <https://sqlite.org/c3ref/overload_function.html>`__\n" 

#define Connection_overloadfunction_USAGE "Connection.overloadfunction(name: str, nargs: int) -> None"

#define Connection_overloadfunction_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(nargs), int)); \
} while(0)


#define  Connection_readonly_DOC "readonly($self,name)\n--\n\nConnection.readonly(name: str) -> bool\n\n" \
"True or False if the named (attached) database was opened readonly or file\n" \
"permissions don't allow writing.  The main database is named \"main\".\n" \
"\n" \
"An exception is raised if the database doesn't exist.\n" \
"\n" \
"Calls: `sqlite3_db_readonly <https://sqlite.org/c3ref/db_readonly.html>`__\n" 

#define Connection_readonly_USAGE "Connection.readonly(name: str) -> bool"

#define Connection_readonly_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_release_memory_DOC "release_memory($self)\n--\n\nConnection.release_memory() -> None\n\n" \
"Attempts to free as much heap memory as possible used by this connection.\n" \
"\n" \
"Calls: `sqlite3_db_release_memory <https://sqlite.org/c3ref/db_release_memory.html>`__\n" 

#define  Connection_rowtrace_DOC ":type: Optional[RowTracer]\n" \
"\n" \
"Called with the cursor and row being returned for\n" \
":class:`cursors <Cursor>` associated with this Connection, unless\n" \
"the Cursor installed its own tracer.  You can change the data that\n" \
"is returned or cause the row to be skipped altogether.\n" \
"\n" \
"If *callable* is *None* then any existing row tracer is\n" \
"removed.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :attr:`Cursor.exectrace`\n" 

#define  Connection_serialize_DOC "serialize($self,name)\n--\n\nConnection.serialize(name: str) -> bytes\n\n" \
"Returns a memory copy of the database. *name* is **\"main\"** for the\n" \
"main database, **\"temp\"** for the temporary database etc.\n" \
"\n" \
"The memory copy is the same as if the database was backed up to\n" \
"disk.\n" \
"\n" \
"If the database name doesn't exist or is empty, then None is\n" \
"returned, not an exception (this is SQLite's behaviour).\n" \
"\n" \
" .. seealso::\n" \
"\n" \
"   * :meth:`Connection.deserialize`\n" \
"\n" \
" Calls: `sqlite3_serialize <https://sqlite.org/c3ref/serialize.html>`__\n" 

#define Connection_serialize_USAGE "Connection.serialize(name: str) -> bytes"

#define Connection_serialize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_set_last_insert_rowid_DOC "set_last_insert_rowid($self,rowid)\n--\n\nConnection.set_last_insert_rowid(rowid: int) -> None\n\n" \
"Sets the value calls to :meth:`last_insert_rowid` will return.\n" \
"\n" \
"Calls: `sqlite3_set_last_insert_rowid <https://sqlite.org/c3ref/set_last_insert_rowid.html>`__\n" 

#define Connection_set_last_insert_rowid_USAGE "Connection.set_last_insert_rowid(rowid: int) -> None"

#define Connection_set_last_insert_rowid_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
} while(0)


#define  Connection_setauthorizer_DOC "setauthorizer($self,callable)\n--\n\nConnection.setauthorizer(callable: Optional[Authorizer]) -> None\n\n" \
"Sets the :attr:`authorizer`\n" 

#define Connection_setauthorizer_callable_MSG  "argument 'callable' of Connection.setauthorizer(callable: Optional[Authorizer]) -> None" 

#define Connection_setauthorizer_USAGE "Connection.setauthorizer(callable: Optional[Authorizer]) -> None"

#define Connection_setauthorizer_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setbusyhandler_DOC "setbusyhandler($self,callable)\n--\n\nConnection.setbusyhandler(callable: Optional[Callable[[int], bool]]) -> None\n\n" \
"Sets the busy handler to callable. callable will be called with one\n" \
"integer argument which is the number of prior calls to the busy\n" \
"callback for the same lock. If the busy callback returns False,\n" \
"then SQLite returns *SQLITE_BUSY* to the calling code. If\n" \
"the callback returns True, then SQLite tries to open the table\n" \
"again and the cycle repeats.\n" \
"\n" \
"If you previously called :meth:`~Connection.setbusytimeout` then\n" \
"calling this overrides that.\n" \
"\n" \
"Passing None unregisters the existing handler.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.setbusytimeout`\n" \
"  * :ref:`Busy handling <busyhandling>`\n" \
"\n" \
"Calls: `sqlite3_busy_handler <https://sqlite.org/c3ref/busy_handler.html>`__\n" 

#define Connection_setbusyhandler_callable_MSG  "argument 'callable' of Connection.setbusyhandler(callable: Optional[Callable[[int], bool]]) -> None" 

#define Connection_setbusyhandler_USAGE "Connection.setbusyhandler(callable: Optional[Callable[[int], bool]]) -> None"

#define Connection_setbusyhandler_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setbusytimeout_DOC "setbusytimeout($self,milliseconds)\n--\n\nConnection.setbusytimeout(milliseconds: int) -> None\n\n" \
"If the database is locked such as when another connection is making\n" \
"changes, SQLite will keep retrying.  This sets the maximum amount of\n" \
"time SQLite will keep retrying before giving up.  If the database is\n" \
"still busy then :class:`apsw.BusyError` will be returned.\n" \
"\n" \
":param milliseconds: Maximum thousandths of a second to wait.\n" \
"\n" \
"If you previously called :meth:`~Connection.setbusyhandler` then\n" \
"calling this overrides that.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :meth:`Connection.setbusyhandler`\n" \
"   * :ref:`Busy handling <busyhandling>`\n" \
"\n" \
"Calls: `sqlite3_busy_timeout <https://sqlite.org/c3ref/busy_timeout.html>`__\n" 

#define Connection_setbusytimeout_USAGE "Connection.setbusytimeout(milliseconds: int) -> None"

#define Connection_setbusytimeout_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(milliseconds), int)); \
} while(0)


#define  Connection_setcommithook_DOC "setcommithook($self,callable)\n--\n\nConnection.setcommithook(callable: Optional[CommitHook]) -> None\n\n" \
"*callable* will be called just before a commit.  It should return\n" \
"False for the commit to go ahead and True for it to be turned\n" \
"into a rollback. In the case of an exception in your callable, a\n" \
"True (ie rollback) value is returned.  Pass None to unregister\n" \
"the existing hook.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_commit_hook>`\n" \
"\n" \
"Calls: `sqlite3_commit_hook <https://sqlite.org/c3ref/commit_hook.html>`__\n" 

#define Connection_setcommithook_callable_MSG  "argument 'callable' of Connection.setcommithook(callable: Optional[CommitHook]) -> None" 

#define Connection_setcommithook_USAGE "Connection.setcommithook(callable: Optional[CommitHook]) -> None"

#define Connection_setcommithook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setexectrace_DOC "setexectrace($self,callable)\n--\n\nConnection.setexectrace(callable: Optional[ExecTracer]) -> None\n\n" \
"Method to set :attr:`Connection.exectrace`\n" 

#define Connection_setexectrace_callable_MSG  "argument 'callable' of Connection.setexectrace(callable: Optional[ExecTracer]) -> None" 

#define Connection_setexectrace_USAGE "Connection.setexectrace(callable: Optional[ExecTracer]) -> None"

#define Connection_setexectrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setprofile_DOC "setprofile($self,callable)\n--\n\nConnection.setprofile(callable: Optional[Callable[[str, int], None]]) -> None\n\n" \
"Sets a callable which is invoked at the end of execution of each\n" \
"statement and passed the statement string and how long it took to\n" \
"execute. (The execution time is in nanoseconds.) Note that it is\n" \
"called only on completion. If for example you do a ``SELECT`` and\n" \
"only read the first result, then you won't reach the end of the\n" \
"statement.\n" \
"\n" \
"Calls: `sqlite3_profile <https://sqlite.org/c3ref/profile.html>`__\n" 

#define Connection_setprofile_callable_MSG  "argument 'callable' of Connection.setprofile(callable: Optional[Callable[[str, int], None]]) -> None" 

#define Connection_setprofile_USAGE "Connection.setprofile(callable: Optional[Callable[[str, int], None]]) -> None"

#define Connection_setprofile_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setprogresshandler_DOC "setprogresshandler($self,callable,nsteps=20)\n--\n\nConnection.setprogresshandler(callable: Optional[Callable[[], bool]], nsteps: int = 20) -> None\n\n" \
"Sets a callable which is invoked every *nsteps* SQLite\n" \
"inststructions. The callable should return True to abort\n" \
"or False to continue. (If there is an error in your Python *callable*\n" \
"then True/abort will be returned).\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example_progress_handler>`\n" \
"\n" \
"Calls: `sqlite3_progress_handler <https://sqlite.org/c3ref/progress_handler.html>`__\n" 

#define Connection_setprogresshandler_callable_MSG  "argument 'callable' of Connection.setprogresshandler(callable: Optional[Callable[[], bool]], nsteps: int = 20) -> None" 

#define Connection_setprogresshandler_USAGE "Connection.setprogresshandler(callable: Optional[Callable[[], bool]], nsteps: int = 20) -> None"

#define Connection_setprogresshandler_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(nsteps), int)); \
  assert(nsteps == (20)); \
} while(0)


#define  Connection_setrollbackhook_DOC "setrollbackhook($self,callable)\n--\n\nConnection.setrollbackhook(callable: Optional[Callable[[], None]]) -> None\n\n" \
"Sets a callable which is invoked during a rollback.  If *callable*\n" \
"is *None* then any existing rollback hook is unregistered.\n" \
"\n" \
"The *callable* is called with no parameters and the return value is ignored.\n" \
"\n" \
"Calls: `sqlite3_rollback_hook <https://sqlite.org/c3ref/commit_hook.html>`__\n" 

#define Connection_setrollbackhook_callable_MSG  "argument 'callable' of Connection.setrollbackhook(callable: Optional[Callable[[], None]]) -> None" 

#define Connection_setrollbackhook_USAGE "Connection.setrollbackhook(callable: Optional[Callable[[], None]]) -> None"

#define Connection_setrollbackhook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setrowtrace_DOC "setrowtrace($self,callable)\n--\n\nConnection.setrowtrace(callable: Optional[RowTracer]) -> None\n\n" \
"Method to set :attr:`Connection.rowtrace`\n" 

#define Connection_setrowtrace_callable_MSG  "argument 'callable' of Connection.setrowtrace(callable: Optional[RowTracer]) -> None" 

#define Connection_setrowtrace_USAGE "Connection.setrowtrace(callable: Optional[RowTracer]) -> None"

#define Connection_setrowtrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setupdatehook_DOC "setupdatehook($self,callable)\n--\n\nConnection.setupdatehook(callable: Optional[Callable[[int, str, str, int], None]]) -> None\n\n" \
"Calls *callable* whenever a row is updated, deleted or inserted.  If\n" \
"*callable* is *None* then any existing update hook is\n" \
"unregistered.  The update hook cannot make changes to the database while\n" \
"the query is still executing, but can record them for later use or\n" \
"apply them in a different connection.\n" \
"\n" \
"The update hook is called with 4 parameters:\n" \
"\n" \
"  type (int)\n" \
"    *SQLITE_INSERT*, *SQLITE_DELETE* or *SQLITE_UPDATE*\n" \
"  database name (string)\n" \
"    This is ``main`` for the database or the name specified in\n" \
"    `ATTACH <https://sqlite.org/lang_attach.html>`_\n" \
"  table name (string)\n" \
"    The table on which the update happened\n" \
"  rowid (64 bit integer)\n" \
"    The affected row\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    * :ref:`Example <example_update_hook>`\n" \
"\n" \
"Calls: `sqlite3_update_hook <https://sqlite.org/c3ref/update_hook.html>`__\n" 

#define Connection_setupdatehook_callable_MSG  "argument 'callable' of Connection.setupdatehook(callable: Optional[Callable[[int, str, str, int], None]]) -> None" 

#define Connection_setupdatehook_USAGE "Connection.setupdatehook(callable: Optional[Callable[[int, str, str, int], None]]) -> None"

#define Connection_setupdatehook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setwalhook_DOC "setwalhook($self,callable)\n--\n\nConnection.setwalhook(callable: Optional[Callable[[Connection, str, int], int]]) -> None\n\n" \
"*callable* will be called just after data is committed in :ref:`wal`\n" \
"mode.  It should return *SQLITE_OK* or an error code.  The\n" \
"callback is called with 3 parameters:\n" \
"\n" \
"  * The Connection\n" \
"  * The database name (eg \"main\" or the name of an attached database)\n" \
"  * The number of pages in the wal log\n" \
"\n" \
"You can pass in None in order to unregister an existing hook.\n" \
"\n" \
"Calls: `sqlite3_wal_hook <https://sqlite.org/c3ref/wal_hook.html>`__\n" 

#define Connection_setwalhook_callable_MSG  "argument 'callable' of Connection.setwalhook(callable: Optional[Callable[[Connection, str, int], int]]) -> None" 

#define Connection_setwalhook_USAGE "Connection.setwalhook(callable: Optional[Callable[[Connection, str, int], int]]) -> None"

#define Connection_setwalhook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_sqlite3pointer_DOC "sqlite3pointer($self)\n--\n\nConnection.sqlite3pointer() -> int\n\n" \
"Returns the underlying `sqlite3 *\n" \
"<https://sqlite.org/c3ref/sqlite3.html>`_ for the connection. This\n" \
"method is useful if there are other C level libraries in the same\n" \
"process and you want them to use the APSW connection handle. The value\n" \
"is returned as a number using `PyLong_FromVoidPtr\n" \
"<https://docs.python.org/3/c-api/long.html?highlight=pylong_fromvoidptr#c.PyLong_FromVoidPtr>`__\n" \
"under the hood. You should also ensure that you increment the\n" \
"reference count on the :class:`Connection` for as long as the other\n" \
"libraries are using the pointer.  It is also a very good idea to call\n" \
":meth:`sqlitelibversion` and ensure it is the same as the other\n" \
"libraries.\n" 

#define  Connection_status_DOC "status($self,op,reset=False)\n--\n\nConnection.status(op: int, reset: bool = False) -> Tuple[int, int]\n\n" \
"Returns current and highwater measurements for the database.\n" \
"\n" \
":param op: A `status parameter <https://sqlite.org/c3ref/c_dbstatus_options.html>`_\n" \
":param reset: If *True* then the highwater is set to the current value\n" \
":returns: A tuple of current value and highwater value\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  The :func:`status` example which works in exactly the same way.\n" \
"\n" \
"  * :ref:`Status example <example_status>`\n" \
"\n" \
"Calls: `sqlite3_db_status <https://sqlite.org/c3ref/db_status.html>`__\n" 

#define Connection_status_reset_MSG  "argument 'reset' of Connection.status(op: int, reset: bool = False) -> Tuple[int, int]" 

#define Connection_status_USAGE "Connection.status(op: int, reset: bool = False) -> Tuple[int, int]"

#define Connection_status_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Connection_system_errno_DOC ":type: int\n" \
"\n" \
"The underlying system error code for the most recent I/O errors or failing to open files.\n" \
"\n" \
"Calls: `sqlite3_system_errno <https://sqlite.org/c3ref/system_errno.html>`__\n" 

#define  Connection_table_exists_DOC "table_exists($self,dbname,table_name)\n--\n\nConnection.table_exists(dbname: Optional[str], table_name: str) -> bool\n\n" \
"Returns True if the named table exists, else False.\n" \
"\n" \
"`dbname` is the specific database (eg \"main\", \"temp\") or None to search\n" \
"all databases\n" \
"\n" \
"Calls: `sqlite3_table_column_metadata <https://sqlite.org/c3ref/table_column_metadata.html>`__\n" 

#define Connection_table_exists_USAGE "Connection.table_exists(dbname: Optional[str], table_name: str) -> bool"

#define Connection_table_exists_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table_name), const char *)); \
} while(0)


#define  Connection_totalchanges_DOC "totalchanges($self)\n--\n\nConnection.totalchanges() -> int\n\n" \
"Returns the total number of database rows that have be modified,\n" \
"inserted, or deleted since the database connection was opened.\n" \
"\n" \
"Calls: `sqlite3_total_changes64 <https://sqlite.org/c3ref/total_changes.html>`__\n" 

#define  Connection_trace_v2_DOC "trace_v2($self,mask,callback=None)\n--\n\nConnection.trace_v2(mask: int, callback: Optional[Callable[[dict], None]] = None) -> None\n\n" \
"Registers a trace callback.  The callback is called with a dict of relevant values based\n" \
"on the code.\n" \
"\n" \
".. list-table::\n" \
"  :header-rows: 1\n" \
"  :widths: auto\n" \
"\n" \
"  * - Key\n" \
"    - Type\n" \
"    - Explanation\n" \
"  * - code\n" \
"    - :class:`int`\n" \
"    - One of the `trace event codes <https://www.sqlite.org/c3ref/c_trace.html>`__\n" \
"  * - connection\n" \
"    - :class:`Connection`\n" \
"    - Connection this trace event belongs to\n" \
"  * - sql\n" \
"    - :class:`str`\n" \
"    - SQL text (except SQLITE_TRACE_CLOSE)\n" \
"  * - profile\n" \
"    - :class:`int`\n" \
"    - nanoseconds SQL took to execute (SQLITE_TRACE_PROFILE only)\n" \
"  * - stmt_status\n" \
"    - :class:`dict`\n" \
"    - SQLITE_TRACE_PROFILE only: Keys are names from `status parameters\n" \
"      <https://www.sqlite.org/c3ref/c_stmtstatus_counter.html>`__ - eg\n" \
"      *\"SQLITE_STMTSTATUS_VM_STEP\"* and corresponding integer values.\n" \
"      The counters are reset each time a statement\n" \
"      starts execution.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example_trace_v2>`\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_trace_v2 <https://sqlite.org/c3ref/trace_v2.html>`__\n" \
"  * `sqlite3_stmt_status <https://sqlite.org/c3ref/stmt_status.html>`__\n" 

#define Connection_trace_v2_callback_MSG  "argument 'callback' of Connection.trace_v2(mask: int, callback: Optional[Callable[[dict], None]] = None) -> None" 

#define Connection_trace_v2_USAGE "Connection.trace_v2(mask: int, callback: Optional[Callable[[dict], None]] = None) -> None"

#define Connection_trace_v2_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(mask), int)); \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
  assert(callback == NULL); \
} while(0)


#define  Connection_txn_state_DOC "txn_state($self,schema=None)\n--\n\nConnection.txn_state(schema: Optional[str] = None) -> int\n\n" \
"Returns the current transaction state of the database, or a specific schema\n" \
"if provided.  ValueError is raised if schema is not None or a valid schema name.\n" \
":attr:`apsw.mapping_txn_state` contains the names and values returned.\n" \
"\n" \
"Calls: `sqlite3_txn_state <https://sqlite.org/c3ref/txn_state.html>`__\n" 

#define Connection_txn_state_USAGE "Connection.txn_state(schema: Optional[str] = None) -> int"

#define Connection_txn_state_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
  assert(schema == 0); \
} while(0)


#define  Connection_vtab_config_DOC "vtab_config($self,op,val=0)\n--\n\nConnection.vtab_config(op: int, val: int = 0) -> None\n\n" \
"Called during virtual table connect/create.\n" \
"\n" \
"Calls: `sqlite3_vtab_config <https://sqlite.org/c3ref/vtab_config.html>`__\n" 

#define Connection_vtab_config_USAGE "Connection.vtab_config(op: int, val: int = 0) -> None"

#define Connection_vtab_config_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(val), int)); \
  assert(val == (0)); \
} while(0)


#define  Connection_vtab_on_conflict_DOC "vtab_on_conflict($self)\n--\n\nConnection.vtab_on_conflict() -> int\n\n" \
"Called during virtual table xUpdate\n" \
"\n" \
"Calls: `sqlite3_vtab_on_conflict <https://sqlite.org/c3ref/vtab_on_conflict.html>`__\n" 

#define  Connection_wal_autocheckpoint_DOC "wal_autocheckpoint($self,n)\n--\n\nConnection.wal_autocheckpoint(n: int) -> None\n\n" \
"Sets how often the :ref:`wal` checkpointing is run.\n" \
"\n" \
" :param n: A number representing the checkpointing interval or\n" \
"   zero/negative to disable auto checkpointing.\n" \
"\n" \
"Calls: `sqlite3_wal_autocheckpoint <https://sqlite.org/c3ref/wal_autocheckpoint.html>`__\n" 

#define Connection_wal_autocheckpoint_USAGE "Connection.wal_autocheckpoint(n: int) -> None"

#define Connection_wal_autocheckpoint_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(n), int)); \
} while(0)


#define  Connection_wal_checkpoint_DOC "wal_checkpoint($self,dbname=None,mode=apsw.SQLITE_CHECKPOINT_PASSIVE)\n--\n\nConnection.wal_checkpoint(dbname: Optional[str] = None, mode: int = apsw.SQLITE_CHECKPOINT_PASSIVE) -> Tuple[int, int]\n\n" \
"Does a WAL checkpoint.  Has no effect if the database(s) are not in WAL mode.\n" \
"\n" \
"  :param dbname:  The name of the database or all databases if None\n" \
"\n" \
"  :param mode: One of the `checkpoint modes <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.\n" \
"\n" \
"  :return: A tuple of the size of the WAL log in frames and the\n" \
"     number of frames checkpointed as described in the\n" \
"     `documentation\n" \
"     <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.\n" \
"\n" \
"Calls: `sqlite3_wal_checkpoint_v2 <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__\n" 

#define Connection_wal_checkpoint_USAGE "Connection.wal_checkpoint(dbname: Optional[str] = None, mode: int = apsw.SQLITE_CHECKPOINT_PASSIVE) -> Tuple[int, int]"

#define Connection_wal_checkpoint_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(dbname == 0); \
  assert(__builtin_types_compatible_p(typeof(mode), int)); \
  assert(mode == (SQLITE_CHECKPOINT_PASSIVE)); \
} while(0)


#define  Cursor_class_DOC "You obtain cursors by calling :meth:`Connection.cursor`.\n" 

#define  Cursor_close_DOC "close($self,force=False)\n--\n\nCursor.close(force: bool = False) -> None\n\n" \
"It is very unlikely you will need to call this method.  It exists\n" \
"because older versions of SQLite required all Connection/Cursor\n" \
"activity to be confined to the same thread.  That is no longer the\n" \
"case.  Cursors are automatically garbage collected and when there\n" \
"are none left will allow the connection to be garbage collected if\n" \
"it has no other references.\n" \
"\n" \
"A cursor is open if there are remaining statements to execute (if\n" \
"your query included multiple statements), or if you called\n" \
":meth:`~Cursor.executemany` and not all of the *sequenceofbindings*\n" \
"have been used yet.\n" \
"\n" \
":param force: If False then you will get exceptions if there is\n" \
" remaining work to do be in the Cursor such as more statements to\n" \
" execute, more data from the executemany binding sequence etc. If\n" \
" force is True then all remaining work and state information will be\n" \
" silently discarded.\n" 

#define Cursor_close_force_MSG  "argument 'force' of Cursor.close(force: bool = False) -> None" 

#define Cursor_close_USAGE "Cursor.close(force: bool = False) -> None"

#define Cursor_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Cursor_connection_DOC ":type: Connection\n" \
"\n" \
":class:`Connection` this cursor is using\n" 

#define  Cursor_description_DOC ":type: Tuple[Tuple[str, str, None, None, None, None, None], ...]\n" \
"\n" \
"Based on the `DB-API cursor property\n" \
"<http://www.python.org/dev/peps/pep-0249/>`__, this returns the\n" \
"same as :meth:`getdescription` but with 5 Nones appended.  See\n" \
"also :issue:`131`.\n" 

#define  Cursor_description_full_DOC ":type: Tuple[Tuple[str, str, str, str, str], ...]\n" \
"\n" \
"Only present if SQLITE_ENABLE_COLUMN_METADATA was defined at\n" \
"compile time.\n" \
"\n" \
"Returns all information about the query result columns. In\n" \
"addition to the name and declared type, you also get the database\n" \
"name, table name, and origin name.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_column_name <https://sqlite.org/c3ref/column_name.html>`__\n" \
"  * `sqlite3_column_decltype <https://sqlite.org/c3ref/column_decltype.html>`__\n" \
"  * `sqlite3_column_database_name <https://sqlite.org/c3ref/column_database_name.html>`__\n" \
"  * `sqlite3_column_table_name <https://sqlite.org/c3ref/column_database_name.html>`__\n" \
"  * `sqlite3_column_origin_name <https://sqlite.org/c3ref/column_database_name.html>`__\n" 

#define  Cursor_exectrace_DOC ":type: Optional[ExecTracer]\n" \
"\n" \
"Called with the cursor, statement and bindings for\n" \
"each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this\n" \
"cursor.\n" \
"\n" \
"If *callable* is *None* then any existing execution tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`executiontracer`\n" \
"  * :attr:`Connection.exectrace`\n" 

#define  Cursor_execute_DOC "execute($self,statements,bindings=None,*,can_cache=True,prepare_flags=0)\n--\n\nCursor.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor\n\n" \
"Executes the statements using the supplied bindings.  Execution\n" \
"returns when the first row is available or all statements have\n" \
"completed.\n" \
"\n" \
":param statements: One or more SQL statements such as ``select *\n" \
"  from books`` or ``begin; insert into books ...; select\n" \
"  last_insert_rowid(); end``.\n" \
":param bindings: If supplied should either be a sequence or a dictionary.  Each item must be one of the :ref:`supported types <types>`\n" \
":param can_cache: If False then the statement cache will not be used to find an already prepared query, nor will it be\n" \
"  placed in the cache after execution\n" \
":param prepare_flags: `flags <https://sqlite.org/c3ref/c_prepare_normalize.htm>`__ passed to\n" \
"  `sqlite_prepare_v3 <https://sqlite.org/c3ref/prepare.html>`__\n" \
"\n" \
"If you use numbered bindings in the query then supply a sequence.\n" \
"Any sequence will work including lists and iterators.  For\n" \
"example::\n" \
"\n" \
"  cursor.execute(\"insert into books values(?,?)\", (\"title\", \"number\"))\n" \
"\n" \
".. note::\n" \
"\n" \
"  A common gotcha is wanting to insert a single string but not\n" \
"  putting it in a tuple::\n" \
"\n" \
"    cursor.execute(\"insert into books values(?)\", \"a title\")\n" \
"\n" \
"  The string is a sequence of 8 characters and so it will look\n" \
"  like you are supplying 8 bindings when only one is needed.  Use\n" \
"  a one item tuple with a trailing comma like this::\n" \
"\n" \
"    cursor.execute(\"insert into books values(?)\", (\"a title\",) )\n" \
"\n" \
"If you used names in the statement then supply a dictionary as the\n" \
"binding.  It is ok to be missing entries from the dictionary -\n" \
"None/null will be used.  For example::\n" \
"\n" \
"   cursor.execute(\"insert into books values(:title, :isbn, :rating)\",\n" \
"        {\"title\": \"book title\", \"isbn\": 908908908})\n" \
"\n" \
"The return is the cursor object itself which is also an iterator.  This allows you to write::\n" \
"\n" \
"   for row in cursor.execute(\"select * from books\"):\n" \
"      print(row)\n" \
"\n" \
":raises TypeError: The bindings supplied were neither a dict nor a sequence\n" \
":raises BindingsError: You supplied too many or too few bindings for the statements\n" \
":raises IncompleteExecutionError: There are remaining unexecuted queries from your last execute\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_prepare_v3 <https://sqlite.org/c3ref/prepare.html>`__\n" \
"  * `sqlite3_step <https://sqlite.org/c3ref/step.html>`__\n" \
"  * `sqlite3_bind_int64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_null <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_text64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_double <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_blob64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_zeroblob <https://sqlite.org/c3ref/bind_blob.html>`__\n" 

#define Cursor_execute_bindings_MSG  "argument 'bindings' of Cursor.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor" 
#define Cursor_execute_can_cache_MSG  "argument 'can_cache' of Cursor.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor" 

#define Cursor_execute_USAGE "Cursor.execute(statements: str, bindings: Optional[Bindings] = None, *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor"

#define Cursor_execute_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statements), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(bindings), PyObject *)); \
  assert(bindings == NULL); \
  assert(__builtin_types_compatible_p(typeof(can_cache), int)); \
  assert(can_cache == 1); \
  assert(__builtin_types_compatible_p(typeof(prepare_flags), int)); \
  assert(prepare_flags == (0)); \
} while(0)


#define  Cursor_executemany_DOC "executemany($self,statements,sequenceofbindings,*,can_cache=True,prepare_flags=0)\n--\n\nCursor.executemany(statements: str, sequenceofbindings: Sequence[Bindings], *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor\n\n" \
"This method is for when you want to execute the same statements over\n" \
"a sequence of bindings.  Conceptually it does this::\n" \
"\n" \
"  for binding in sequenceofbindings:\n" \
"      cursor.execute(statements, binding)\n" \
"\n" \
"Example::\n" \
"\n" \
"  rows=(  (1, 7),\n" \
"          (2, 23),\n" \
"          (4, 92),\n" \
"          (12, 12) )\n" \
"\n" \
"  cursor.executemany(\"insert into nums values(?,?)\", rows)\n" \
"\n" \
"The return is the cursor itself which acts as an iterator.  Your\n" \
"statements can return data.  See :meth:`~Cursor.execute` for more\n" \
"information.\n" 

#define Cursor_executemany_can_cache_MSG  "argument 'can_cache' of Cursor.executemany(statements: str, sequenceofbindings: Sequence[Bindings], *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor" 

#define Cursor_executemany_USAGE "Cursor.executemany(statements: str, sequenceofbindings: Sequence[Bindings], *, can_cache: bool = True, prepare_flags: int = 0) -> Cursor"

#define Cursor_executemany_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statements), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(sequenceofbindings), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(can_cache), int)); \
  assert(can_cache == 1); \
  assert(__builtin_types_compatible_p(typeof(prepare_flags), int)); \
  assert(prepare_flags == (0)); \
} while(0)


#define  Cursor_expanded_sql_DOC ":type: str\n" \
"\n" \
"The SQL text with bound parameters expanded.  For example::\n" \
"\n" \
"   execute(\"select ?, ?\", (3, \"three\"))\n" \
"\n" \
"would return::\n" \
"\n" \
"   select 3, 'three'\n" \
"\n" \
"Note that while SQLite supports nulls in strings, their implementation\n" \
"of sqlite3_expanded_sql stops at the first null.\n" \
"\n" \
"You will get :exc:`MemoryError` if SQLite ran out of memory, or if\n" \
"the expanded string would exceed `SQLITE_LIMIT_LENGTH\n" \
"<https://www.sqlite.org/c3ref/c_limit_attached.html>`__.\n" \
"\n" \
"Calls: `sqlite3_expanded_sql <https://sqlite.org/c3ref/expanded_sql.html>`__\n" 

#define  Cursor_fetchall_DOC "fetchall($self)\n--\n\nCursor.fetchall() -> list[Tuple[SQLiteValue, ...]]\n\n" \
"Returns all remaining result rows as a list.  This method is defined\n" \
"in DBAPI.  It is a longer way of doing ``list(cursor)``.\n" 

#define  Cursor_fetchone_DOC "fetchone($self)\n--\n\nCursor.fetchone() -> Optional[Any]\n\n" \
"Returns the next row of data or None if there are no more rows.\n" 

#define  Cursor_getconnection_DOC "getconnection($self)\n--\n\nCursor.getconnection() -> Connection\n\n" \
"Returns the :attr:`connection` this cursor is using\n" 

#define  Cursor_getdescription_DOC "getdescription($self)\n--\n\nCursor.getdescription() -> Tuple[Tuple[str, str], ...]\n\n" \
"If you are trying to get information about a table or view,\n" \
"then `pragma table_info <https://sqlite.org/pragma.html#pragma_table_info>`__\n" \
"is better.\n" \
"\n" \
"Returns a tuple describing each column in the result row.  The\n" \
"return is identical for every row of the results.  You can only\n" \
"call this method once you have started executing a statement and\n" \
"before you have finished::\n" \
"\n" \
"   # This will error\n" \
"   cursor.getdescription()\n" \
"\n" \
"   for row in cursor.execute(\"select .....\"):\n" \
"      # this works\n" \
"      print (cursor.getdescription())\n" \
"      print (row)\n" \
"\n" \
"The information about each column is a tuple of ``(column_name,\n" \
"declared_column_type)``.  The type is what was declared in the\n" \
"``CREATE TABLE`` statement - the value returned in the row will be\n" \
"whatever type you put in for that row and column.  (This is known\n" \
"as `manifest typing <https://sqlite.org/different.html#typing>`_\n" \
"which is also the way that Python works.  The variable ``a`` could\n" \
"contain an integer, and then you could put a string in it.  Other\n" \
"static languages such as C or other SQL databases only let you put\n" \
"one type in - eg ``a`` could only contain an integer or a string,\n" \
"but never both.)\n" \
"\n" \
"Example::\n" \
"\n" \
"   cursor.execute(\"create table books(title string, isbn number, wibbly wobbly zebra)\")\n" \
"   cursor.execute(\"insert into books values(?,?,?)\", (97, \"fjfjfj\", 3.7))\n" \
"   cursor.execute(\"insert into books values(?,?,?)\", (\"fjfjfj\", 3.7, 97))\n" \
"\n" \
"   for row in cursor.execute(\"select * from books\"):\n" \
"      print (cursor.getdescription())\n" \
"      print (row)\n" \
"\n" \
"Output::\n" \
"\n" \
"  # row 0 - description\n" \
"  (('title', 'string'), ('isbn', 'number'), ('wibbly', 'wobbly zebra'))\n" \
"  # row 0 - values\n" \
"  (97, 'fjfjfj', 3.7)\n" \
"  # row 1 - description\n" \
"  (('title', 'string'), ('isbn', 'number'), ('wibbly', 'wobbly zebra'))\n" \
"  # row 1 - values\n" \
"  ('fjfjfj', 3.7, 97)\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_column_name <https://sqlite.org/c3ref/column_name.html>`__\n" \
"  * `sqlite3_column_decltype <https://sqlite.org/c3ref/column_decltype.html>`__\n" 

#define  Cursor_getexectrace_DOC "getexectrace($self)\n--\n\nCursor.getexectrace() -> Optional[ExecTracer]\n\n" \
"Returns the currently installed :attr:`execution tracer\n" \
"<Cursor.exectrace>`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define  Cursor_getrowtrace_DOC "getrowtrace($self)\n--\n\nCursor.getrowtrace() -> Optional[RowTracer]\n\n" \
"Returns the currently installed (via :meth:`~Cursor.setrowtrace`)\n" \
"row tracer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define  Cursor_is_explain_DOC ":type: int\n" \
"\n" \
"Returns 0 if executing a normal query, 1 if it is an EXPLAIN query,\n" \
"and 2 if an EXPLAIN QUERY PLAN query.\n" \
"\n" \
"Calls: `sqlite3_stmt_isexplain <https://sqlite.org/c3ref/stmt_isexplain.html>`__\n" 

#define  Cursor_is_readonly_DOC ":type: bool\n" \
"\n" \
"Returns True if the current query does not change the database.\n" \
"\n" \
"Note that called functions, virtual tables etc could make changes though.\n" \
"\n" \
"Calls: `sqlite3_stmt_readonly <https://sqlite.org/c3ref/stmt_readonly.html>`__\n" 

#define  Cursor_iter_DOC "__iter__($self,self)\n--\n\nCursor.__iter__(self: Cursor) -> Cursor\n\n" \
"Cursors are iterators\n" 

#define  Cursor_next_DOC "__next__($self,self)\n--\n\nCursor.__next__(self: Cursor) -> Any\n\n" \
"Cursors are iterators\n" 

#define  Cursor_rowtrace_DOC ":type: Optional[RowTracer]\n" \
"\n" \
"Called with cursor and row being returned.  You can\n" \
"change the data that is returned or cause the row to be skipped\n" \
"altogether.\n" \
"\n" \
"If *callable* is *None* then any existing row tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :attr:`Connection.rowtrace`\n" 

#define  Cursor_setexectrace_DOC "setexectrace($self,callable)\n--\n\nCursor.setexectrace(callable: Optional[ExecTracer]) -> None\n\n" \
"Sets the :attr:`execution tracer <Cursor.exectrace>`\n" 

#define Cursor_setexectrace_callable_MSG  "argument 'callable' of Cursor.setexectrace(callable: Optional[ExecTracer]) -> None" 

#define Cursor_setexectrace_USAGE "Cursor.setexectrace(callable: Optional[ExecTracer]) -> None"

#define Cursor_setexectrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Cursor_setrowtrace_DOC "setrowtrace($self,callable)\n--\n\nCursor.setrowtrace(callable: Optional[RowTracer]) -> None\n\n" \
"Sets the :attr:`row tracer <Cursor.rowtrace>`\n" 

#define Cursor_setrowtrace_callable_MSG  "argument 'callable' of Cursor.setrowtrace(callable: Optional[RowTracer]) -> None" 

#define Cursor_setrowtrace_USAGE "Cursor.setrowtrace(callable: Optional[RowTracer]) -> None"

#define Cursor_setrowtrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  IndexInfo_class_DOC "IndexInfo represents the `sqlite3_index_info\n" \
"<https://www.sqlite.org/c3ref/index_info.html>`__ and associated\n" \
"methods used in the :meth:`VTTable.BestIndexObject` method.  The\n" \
"structure values are not altered or made friendlier in any way.\n" \
"\n" \
"Naming is identical to the C structure rather than Pythonic.  You can\n" \
"access members directly while needing to use get/set methods for array\n" \
"members.\n" \
"\n" \
"You will get :exc:`ValueError` if you use the object outside of an\n" \
"BestIndex method.\n" \
"\n" \
":meth:`apsw.ext.index_info_to_dict` provides a convenient\n" \
"representation of this object as a :class:`dict`.\n" 

#define  IndexInfo_colUsed_DOC ":type: set[int]\n" \
"\n" \
"(Read-only) Columns used by the statement.  Note that a set is returned, not\n" \
"the underlying integer.\n" 

#define  IndexInfo_distinct_DOC ":type: int\n" \
"\n" \
"(Read-only) How the query planner would like output ordered\n" \
"\n" \
"Calls: `sqlite3_vtab_distinct <https://sqlite.org/c3ref/vtab_distinct.html>`__\n" 

#define  IndexInfo_estimatedCost_DOC ":type: float\n" \
"\n" \
"Estimated cost of using this index\n" 

#define  IndexInfo_estimatedRows_DOC ":type: int\n" \
"\n" \
"Estimated number of rows returned\n" 

#define  IndexInfo_get_aConstraintUsage_argvIndex_DOC "get_aConstraintUsage_argvIndex($self,which)\n--\n\nIndexInfo.get_aConstraintUsage_argvIndex(which: int) -> int\n\n" \
"Returns *argvIndex* for *aConstraintUsage[which]*\n" 

#define IndexInfo_get_aConstraintUsage_argvIndex_USAGE "IndexInfo.get_aConstraintUsage_argvIndex(which: int) -> int"

#define IndexInfo_get_aConstraintUsage_argvIndex_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraintUsage_in_DOC "get_aConstraintUsage_in($self,which)\n--\n\nIndexInfo.get_aConstraintUsage_in(which: int) -> bool\n\n" \
"Returns True if the constraint is *in* - eg column in (3, 7, 9)\n" \
"\n" \
"Calls: `sqlite3_vtab_in <https://sqlite.org/c3ref/vtab_in.html>`__\n" 

#define IndexInfo_get_aConstraintUsage_in_USAGE "IndexInfo.get_aConstraintUsage_in(which: int) -> bool"

#define IndexInfo_get_aConstraintUsage_in_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraintUsage_omit_DOC "get_aConstraintUsage_omit($self,which)\n--\n\nIndexInfo.get_aConstraintUsage_omit(which: int) -> bool\n\n" \
"Returns *omit* for *aConstraintUsage[which]*\n" 

#define IndexInfo_get_aConstraintUsage_omit_USAGE "IndexInfo.get_aConstraintUsage_omit(which: int) -> bool"

#define IndexInfo_get_aConstraintUsage_omit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_collation_DOC "get_aConstraint_collation($self,which)\n--\n\nIndexInfo.get_aConstraint_collation(which: int) -> str\n\n" \
"Returns collation name for *aConstraint[which]*\n" \
"\n" \
"Calls: `sqlite3_vtab_collation <https://sqlite.org/c3ref/vtab_collation.html>`__\n" 

#define IndexInfo_get_aConstraint_collation_USAGE "IndexInfo.get_aConstraint_collation(which: int) -> str"

#define IndexInfo_get_aConstraint_collation_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_iColumn_DOC "get_aConstraint_iColumn($self,which)\n--\n\nIndexInfo.get_aConstraint_iColumn(which: int) -> int\n\n" \
"Returns *iColumn* for *aConstraint[which]*\n" 

#define IndexInfo_get_aConstraint_iColumn_USAGE "IndexInfo.get_aConstraint_iColumn(which: int) -> int"

#define IndexInfo_get_aConstraint_iColumn_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_op_DOC "get_aConstraint_op($self,which)\n--\n\nIndexInfo.get_aConstraint_op(which: int) -> int\n\n" \
"Returns *op* for *aConstraint[which]*\n" 

#define IndexInfo_get_aConstraint_op_USAGE "IndexInfo.get_aConstraint_op(which: int) -> int"

#define IndexInfo_get_aConstraint_op_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_rhs_DOC "get_aConstraint_rhs($self,which)\n--\n\nIndexInfo.get_aConstraint_rhs(which: int) -> SQLiteValue\n\n" \
"Returns right hand side value if known, else None.\n" \
"\n" \
"Calls: `sqlite3_vtab_rhs_value <https://sqlite.org/c3ref/vtab_rhs_value.html>`__\n" 

#define IndexInfo_get_aConstraint_rhs_USAGE "IndexInfo.get_aConstraint_rhs(which: int) -> SQLiteValue"

#define IndexInfo_get_aConstraint_rhs_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aConstraint_usable_DOC "get_aConstraint_usable($self,which)\n--\n\nIndexInfo.get_aConstraint_usable(which: int) -> bool\n\n" \
"Returns *usable* for *aConstraint[which]*\n" 

#define IndexInfo_get_aConstraint_usable_USAGE "IndexInfo.get_aConstraint_usable(which: int) -> bool"

#define IndexInfo_get_aConstraint_usable_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aOrderBy_desc_DOC "get_aOrderBy_desc($self,which)\n--\n\nIndexInfo.get_aOrderBy_desc(which: int) -> bool\n\n" \
"Returns *desc* for *aOrderBy[which]*\n" 

#define IndexInfo_get_aOrderBy_desc_USAGE "IndexInfo.get_aOrderBy_desc(which: int) -> bool"

#define IndexInfo_get_aOrderBy_desc_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_get_aOrderBy_iColumn_DOC "get_aOrderBy_iColumn($self,which)\n--\n\nIndexInfo.get_aOrderBy_iColumn(which: int) -> int\n\n" \
"Returns *iColumn* for *aOrderBy[which]*\n" 

#define IndexInfo_get_aOrderBy_iColumn_USAGE "IndexInfo.get_aOrderBy_iColumn(which: int) -> int"

#define IndexInfo_get_aOrderBy_iColumn_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
} while(0)


#define  IndexInfo_idxFlags_DOC ":type: int\n" \
"\n" \
"Mask of :attr:`SQLITE_INDEX_SCAN flags <apsw.mapping_virtual_table_scan_flags>`\n" 

#define  IndexInfo_idxNum_DOC ":type: int\n" \
"\n" \
"Number used to identify the index\n" 

#define  IndexInfo_idxStr_DOC ":type: Optional[str]\n" \
"\n" \
"Name used to identify the index\n" 

#define  IndexInfo_nConstraint_DOC ":type: int\n" \
"\n" \
"(Read-only) Number of constraint entries\n" 

#define  IndexInfo_nOrderBy_DOC ":type: int\n" \
"\n" \
"(Read-only) Number of order by  entries\n" 

#define  IndexInfo_orderByConsumed_DOC ":type: bool\n" \
"\n" \
"True if index output is already ordered\n" 

#define  IndexInfo_set_aConstraintUsage_argvIndex_DOC "set_aConstraintUsage_argvIndex($self,which,argvIndex)\n--\n\nIndexInfo.set_aConstraintUsage_argvIndex(which: int, argvIndex: int) -> None\n\n" \
"Sets *argvIndex* for *aConstraintUsage[which]*\n" 

#define IndexInfo_set_aConstraintUsage_argvIndex_USAGE "IndexInfo.set_aConstraintUsage_argvIndex(which: int, argvIndex: int) -> None"

#define IndexInfo_set_aConstraintUsage_argvIndex_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(argvIndex), int)); \
} while(0)


#define  IndexInfo_set_aConstraintUsage_in_DOC "set_aConstraintUsage_in($self,which,filter_all)\n--\n\nIndexInfo.set_aConstraintUsage_in(which: int, filter_all: bool) -> None\n\n" \
"If *which* is an *in* constraint, and *filter_all* is True then your :meth:`VTCursor.Filter`\n" \
"method will have all of the values at once.\n" 

#define IndexInfo_set_aConstraintUsage_in_filter_all_MSG  "argument 'filter_all' of IndexInfo.set_aConstraintUsage_in(which: int, filter_all: bool) -> None" 

#define IndexInfo_set_aConstraintUsage_in_USAGE "IndexInfo.set_aConstraintUsage_in(which: int, filter_all: bool) -> None"

#define IndexInfo_set_aConstraintUsage_in_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(filter_all), int)); \
} while(0)


#define  IndexInfo_set_aConstraintUsage_omit_DOC "set_aConstraintUsage_omit($self,which,omit)\n--\n\nIndexInfo.set_aConstraintUsage_omit(which: int, omit: bool) -> None\n\n" \
"Sets *omit* for *aConstraintUsage[which]*\n" 

#define IndexInfo_set_aConstraintUsage_omit_omit_MSG  "argument 'omit' of IndexInfo.set_aConstraintUsage_omit(which: int, omit: bool) -> None" 

#define IndexInfo_set_aConstraintUsage_omit_USAGE "IndexInfo.set_aConstraintUsage_omit(which: int, omit: bool) -> None"

#define IndexInfo_set_aConstraintUsage_omit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(which), int)); \
  assert(__builtin_types_compatible_p(typeof(omit), int)); \
} while(0)


#define  URIFilename_class_DOC "SQLite uses a convoluted method of storing `uri parameters\n" \
"<https://sqlite.org/uri.html>`__ after the filename binding the\n" \
"C filename representation and parameters together.  This class\n" \
"encapsulates that binding.  The :ref:`example <example_vfs>` shows\n" \
"usage of this class.\n" \
"\n" \
"Your :meth:`VFS.xOpen` method will generally be passed one of\n" \
"these instead of a string as the filename if the URI flag was used\n" \
"or the main database flag is set.\n" \
"\n" \
"You can safely pass it on to the :class:`VFSFile` constructor\n" \
"which knows how to get the name back out.\n" 

#define  URIFilename_filename_DOC "filename($self)\n--\n\nURIFilename.filename() -> str\n\n" \
"Returns the filename.\n" 

#define  URIFilename_uri_boolean_DOC "uri_boolean($self,name,default)\n--\n\nURIFilename.uri_boolean(name: str, default: bool) -> bool\n\n" \
"Returns the boolean value for parameter `name` or `default` if not\n" \
"present.\n" \
"\n" \
"Calls: `sqlite3_uri_boolean <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_boolean_default__MSG  "argument 'default_' of URIFilename.uri_boolean(name: str, default: bool) -> bool" 

#define URIFilename_uri_boolean_USAGE "URIFilename.uri_boolean(name: str, default: bool) -> bool"

#define URIFilename_uri_boolean_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(default_), int)); \
} while(0)


#define  URIFilename_uri_int_DOC "uri_int($self,name,default)\n--\n\nURIFilename.uri_int(name: str, default: int) -> int\n\n" \
"Returns the integer value for parameter `name` or `default` if not\n" \
"present.\n" \
"\n" \
"Calls: `sqlite3_uri_int64 <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_int_USAGE "URIFilename.uri_int(name: str, default: int) -> int"

#define URIFilename_uri_int_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(default_), long long)); \
} while(0)


#define  URIFilename_uri_parameter_DOC "uri_parameter($self,name)\n--\n\nURIFilename.uri_parameter(name: str) -> Optional[str]\n\n" \
"Returns the value of parameter `name` or None.\n" \
"\n" \
"Calls: `sqlite3_uri_parameter <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_parameter_USAGE "URIFilename.uri_parameter(name: str) -> Optional[str]"

#define URIFilename_uri_parameter_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFSFile_class_DOC "Wraps access to a file.  You only need to derive from this class\n" \
"if you want the file object returned from :meth:`VFS.xOpen` to\n" \
"inherit from an existing VFS implementation.\n" \
"\n" \
".. note::\n" \
"\n" \
"   All file sizes and offsets are 64 bit quantities even on 32 bit\n" \
"   operating systems.\n" 

#define  VFSFile_excepthook_DOC "excepthook($self,etype,evalue,etraceback)\n--\n\nVFSFile.excepthook(etype: type[BaseException], evalue: BaseException, etraceback: Optional[types.TracebackType]) ->None\n\n" \
"Called when there has been an exception in a :class:`VFSFile`\n" \
"routine.  The default implementation calls ``sys.excepthook`` and\n" \
"if that fails then ``PyErr_Display``.  The three arguments\n" \
"correspond to what ``sys.exc_info()`` would return.\n" \
"\n" \
":param etype: The exception type\n" \
":param evalue: The exception  value\n" \
":param etraceback: The exception traceback.  Note this\n" \
"  includes all frames all the way up to the thread being started.\n" 

#define  VFSFile_init_DOC "__init__($self,vfs,filename,flags)\n--\n\nVFSFile.__init__(vfs: str, filename: Union[str,URIFilename], flags: List[int])\n\n" \
":param vfs: The vfs you want to inherit behaviour from.  You can\n" \
"   use an empty string ``\"\"`` to inherit from the default vfs.\n" \
":param name: The name of the file being opened.  May be an instance of :class:`URIFilename`.\n" \
":param flags: A two item list ``[inflags, outflags]`` as detailed in :meth:`VFS.xOpen`.\n" \
"\n" \
":raises ValueError: If the named VFS is not registered.\n" \
"\n" \
".. note::\n" \
"\n" \
"  If the VFS that you inherit from supports :ref:`write ahead\n" \
"  logging <wal>` then your :class:`VFSFile` will also support the\n" \
"  xShm methods necessary to implement wal.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`VFS.xOpen`\n" 

#define VFSFile_init_flags_MSG  "argument 'flags' of VFSFile.__init__(vfs: str, filename: Union[str,URIFilename], flags: List[int])" 

#define VFSFile_init_USAGE "VFSFile.__init__(vfs: str, filename: Union[str,URIFilename], flags: List[int])"

#define VFSFile_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(vfs), const char *)); \
  assert(__builtin_types_compatible_p(typeof(filename), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), PyObject *)); \
} while(0)


#define  VFSFile_xCheckReservedLock_DOC "xCheckReservedLock($self)\n--\n\nVFSFile.xCheckReservedLock() -> bool\n\n" \
"Returns True if any database connection (in this or another process)\n" \
"has a lock other than `SQLITE_LOCK_NONE or SQLITE_LOCK_SHARED\n" \
"<https://sqlite.org/c3ref/c_lock_exclusive.html>`_.\n" 

#define  VFSFile_xClose_DOC "xClose($self)\n--\n\nVFSFile.xClose() -> None\n\n" \
"Close the database. Note that even if you return an error you should\n" \
"still close the file.  It is safe to call this method multiple\n" \
"times.\n" 

#define  VFSFile_xDeviceCharacteristics_DOC "xDeviceCharacteristics($self)\n--\n\nVFSFile.xDeviceCharacteristics() -> int\n\n" \
"Return `I/O capabilities\n" \
"<https://sqlite.org/c3ref/c_iocap_atomic.html>`_ (bitwise or of\n" \
"appropriate values). If you do not implement the function or have an\n" \
"error then 0 (the SQLite default) is returned.\n" 

#define  VFSFile_xFileControl_DOC "xFileControl($self,op,ptr)\n--\n\nVFSFile.xFileControl(op: int, ptr: int) -> bool\n\n" \
"Receives `file control\n" \
"<https://sqlite.org/c3ref/file_control.html>`_ request typically\n" \
"issued by :meth:`Connection.filecontrol`.  See\n" \
":meth:`Connection.filecontrol` for an example of how to pass a\n" \
"Python object to this routine.\n" \
"\n" \
":param op: A numeric code.  Codes below 100 are reserved for SQLite\n" \
"  internal use.\n" \
":param ptr: An integer corresponding to a pointer at the C level.\n" \
"\n" \
":returns: A boolean indicating if the op was understood\n" \
"\n" \
"As of SQLite 3.6.10, this method is called by SQLite if you have\n" \
"inherited from an underlying VFSFile.  Consequently ensure you pass\n" \
"any unrecognised codes through to your super class.  For example::\n" \
"\n" \
"         def xFileControl(self, op, ptr):\n" \
"             if op==1027:\n" \
"                 process_quick(ptr)\n" \
"             elif op==1028:\n" \
"                 obj=ctypes.py_object.from_address(ptr).value\n" \
"             else:\n" \
"                 # this ensures superclass implementation is called\n" \
"                 return super(MyFile, self).xFileControl(op, ptr)\n" \
" # we understood the op\n" \
"       return True\n" 

#define VFSFile_xFileControl_ptr_MSG  "argument 'ptr' of VFSFile.xFileControl(op: int, ptr: int) -> bool" 

#define VFSFile_xFileControl_USAGE "VFSFile.xFileControl(op: int, ptr: int) -> bool"

#define VFSFile_xFileControl_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(ptr), void *)); \
} while(0)


#define  VFSFile_xFileSize_DOC "xFileSize($self)\n--\n\nVFSFile.xFileSize() -> int\n\n" \
"Return the size of the file in bytes.  Remember that file sizes are\n" \
"64 bit quantities even on 32 bit operating systems.\n" 

#define  VFSFile_xLock_DOC "xLock($self,level)\n--\n\nVFSFile.xLock(level: int) -> None\n\n" \
"Increase the lock to the level specified which is one of the\n" \
"`SQLITE_LOCK <https://sqlite.org/c3ref/c_lock_exclusive.html>`_\n" \
"family of constants. If you can't increase the lock level because\n" \
"someone else has locked it, then raise :exc:`BusyError`.\n" 

#define VFSFile_xLock_USAGE "VFSFile.xLock(level: int) -> None"

#define VFSFile_xLock_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(level), int)); \
} while(0)


#define  VFSFile_xRead_DOC "xRead($self,amount,offset)\n--\n\nVFSFile.xRead(amount: int, offset: int) -> bytes\n\n" \
"Read the specified *amount* of data starting at *offset*. You\n" \
"should make every effort to read all the data requested, or return\n" \
"an error. If you have the file open for non-blocking I/O or if\n" \
"signals happen then it is possible for the underlying operating\n" \
"system to do a partial read. You will need to request the\n" \
"remaining data. Except for empty files SQLite considers short\n" \
"reads to be a fatal error.\n" \
"\n" \
":param amount: Number of bytes to read\n" \
":param offset: Where to start reading. This number may be 64 bit once the database is larger than 2GB.\n" 

#define VFSFile_xRead_USAGE "VFSFile.xRead(amount: int, offset: int) -> bytes"

#define VFSFile_xRead_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
} while(0)


#define  VFSFile_xSectorSize_DOC "xSectorSize($self)\n--\n\nVFSFile.xSectorSize() -> int\n\n" \
"Return the native underlying sector size. SQLite uses the value\n" \
"returned in determining the default database page size. If you do\n" \
"not implement the function or have an error then 4096 (the SQLite\n" \
"default) is returned.\n" 

#define  VFSFile_xSync_DOC "xSync($self,flags)\n--\n\nVFSFile.xSync(flags: int) -> None\n\n" \
"Ensure data is on the disk platters (ie could survive a power\n" \
"failure immediately after the call returns) with the `sync flags\n" \
"<https://sqlite.org/c3ref/c_sync_dataonly.html>`_ detailing what\n" \
"needs to be synced.  You can sync more than what is requested.\n" 

#define VFSFile_xSync_USAGE "VFSFile.xSync(flags: int) -> None"

#define VFSFile_xSync_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  VFSFile_xTruncate_DOC "xTruncate($self,newsize)\n--\n\nVFSFile.xTruncate(newsize: int) -> None\n\n" \
"Set the file length to *newsize* (which may be more or less than the\n" \
"current length).\n" 

#define VFSFile_xTruncate_USAGE "VFSFile.xTruncate(newsize: int) -> None"

#define VFSFile_xTruncate_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(newsize), long long)); \
} while(0)


#define  VFSFile_xUnlock_DOC "xUnlock($self,level)\n--\n\nVFSFile.xUnlock(level: int) -> None\n\n" \
"Decrease the lock to the level specified which is one of the\n" \
"`SQLITE_LOCK <https://sqlite.org/c3ref/c_lock_exclusive.html>`_\n" \
"family of constants.\n" 

#define VFSFile_xUnlock_USAGE "VFSFile.xUnlock(level: int) -> None"

#define VFSFile_xUnlock_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(level), int)); \
} while(0)


#define  VFSFile_xWrite_DOC "xWrite($self,data,offset)\n--\n\nVFSFile.xWrite(data: bytes, offset: int) -> None\n\n" \
"Write the *data* starting at absolute *offset*. You must write all the data\n" \
"requested, or return an error. If you have the file open for\n" \
"non-blocking I/O or if signals happen then it is possible for the\n" \
"underlying operating system to do a partial write. You will need to\n" \
"write the remaining data.\n" \
"\n" \
":param offset: Where to start writing. This number may be 64 bit once the database is larger than 2GB.\n" 

#define VFSFile_xWrite_USAGE "VFSFile.xWrite(data: bytes, offset: int) -> None"

#define VFSFile_xWrite_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(data), Py_buffer)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
} while(0)


#define  VFS_class_DOC "Provides operating system access.  You can get an overview in the\n" \
"`SQLite documentation <https://sqlite.org/c3ref/vfs.html>`_.  To\n" \
"create a VFS your Python class must inherit from :class:`VFS`.\n" 

#define  VFS_excepthook_DOC "excepthook($self,etype,evalue,etraceback)\n--\n\nVFS.excepthook(etype: type[BaseException], evalue: BaseException, etraceback: Optional[types.TracebackType]) -> Any\n\n" \
"Called when there has been an exception in a :class:`VFS` routine.\n" \
"The default implementation passes the exception information\n" \
"to sqlite3_log, and the first non-error of\n" \
":func:`sys.unraisablehook` and :func:`sys.excepthook`, falling back to\n" \
"`PyErr_Display`.\n" 

#define  VFS_init_DOC "__init__($self,name,base=None,makedefault=False,maxpathname=1024)\n--\n\nVFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024)\n\n" \
":param name: The name to register this vfs under.  If the name\n" \
"    already exists then this vfs will replace the prior one of the\n" \
"    same name.  Use :meth:`apsw.vfsnames` to get a list of\n" \
"    registered vfs names.\n" \
"\n" \
":param base: If you would like to inherit behaviour from an already registered vfs then give\n" \
"    their name.  To inherit from the default vfs, use a zero\n" \
"    length string ``\"\"`` as the name.\n" \
"\n" \
":param makedefault: If true then this vfs will be registered as the default, and will be\n" \
"    used by any opens that don't specify a vfs.\n" \
"\n" \
":param maxpathname: The maximum length of database name in bytes when\n" \
"    represented in UTF-8.  If a pathname is passed in longer than\n" \
"    this value then SQLite will not `be able to open it\n" \
"    <https://sqlite.org/src/tktview/c060923a5422590b3734eb92eae0c94934895b68>`__.\n" \
"\n" \
":raises ValueError: If *base* is not *None* and the named vfs is not\n" \
"  currently registered.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_register <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define VFS_init_makedefault_MSG  "argument 'makedefault' of VFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024)" 

#define VFS_init_USAGE "VFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024)"

#define VFS_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(base), const char *)); \
  assert(base == 0); \
  assert(__builtin_types_compatible_p(typeof(makedefault), int)); \
  assert(makedefault == 0); \
  assert(__builtin_types_compatible_p(typeof(maxpathname), int)); \
  assert(maxpathname == (1024)); \
} while(0)


#define  VFS_unregister_DOC "unregister($self)\n--\n\nVFS.unregister() -> None\n\n" \
"Unregisters the VFS making it unavailable to future database\n" \
"opens. You do not need to call this as the VFS is automatically\n" \
"unregistered by when the VFS has no more references or open\n" \
"databases using it. It is however useful to call if you have made\n" \
"your VFS be the default and wish to immediately make it be\n" \
"unavailable. It is safe to call this routine multiple times.\n" \
"\n" \
"Calls: `sqlite3_vfs_unregister <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define  VFS_xAccess_DOC "xAccess($self,pathname,flags)\n--\n\nVFS.xAccess(pathname: str, flags: int) -> bool\n\n" \
"SQLite wants to check access permissions.  Return True or False\n" \
"accordingly.\n" \
"\n" \
":param pathname: File or directory to check\n" \
":param flags: One of the `access flags <https://sqlite.org/c3ref/c_access_exists.html>`_\n" 

#define VFS_xAccess_USAGE "VFS.xAccess(pathname: str, flags: int) -> bool"

#define VFS_xAccess_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(pathname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  VFS_xCurrentTime_DOC "xCurrentTime($self)\n--\n\nVFS.xCurrentTime()  -> float\n\n" \
"Return the `Julian Day Number\n" \
"<http://en.wikipedia.org/wiki/Julian_day>`_ as a floating point\n" \
"number where the integer portion is the day and the fractional part\n" \
"is the time. Do not adjust for timezone (ie use `UTC\n" \
"<http://en.wikipedia.org/wiki/Universal_Time>`_).\n" 

#define  VFS_xDelete_DOC "xDelete($self,filename,syncdir)\n--\n\nVFS.xDelete(filename: str, syncdir: bool) -> None\n\n" \
"Delete the named file. If the file is missing then raise an\n" \
":exc:`IOError` exception with extendedresult\n" \
"*SQLITE_IOERR_DELETE_NOENT*\n" \
"\n" \
":param filename: File to delete\n" \
"\n" \
":param syncdir: If True then the directory should be synced\n" \
"  ensuring that the file deletion has been recorded on the disk\n" \
"  platters.  ie if there was an immediate power failure after this\n" \
"  call returns, on a reboot the file would still be deleted.\n" 

#define VFS_xDelete_syncdir_MSG  "argument 'syncdir' of VFS.xDelete(filename: str, syncdir: bool) -> None" 

#define VFS_xDelete_USAGE "VFS.xDelete(filename: str, syncdir: bool) -> None"

#define VFS_xDelete_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(syncdir), int)); \
} while(0)


#define  VFS_xDlClose_DOC "xDlClose($self,handle)\n--\n\nVFS.xDlClose(handle: int) -> None\n\n" \
"Close and unload the library corresponding to the handle you\n" \
"returned from :meth:`~VFS.xDlOpen`.  You can use ctypes to do\n" \
"this::\n" \
"\n" \
"  def xDlClose(handle):\n" \
"     # Note leading underscore in _ctypes\n" \
"     _ctypes.dlclose(handle)       # Linux/Mac/Unix\n" \
"     _ctypes.FreeLibrary(handle)   # Windows\n" 

#define VFS_xDlClose_handle_MSG  "argument 'handle' of VFS.xDlClose(handle: int) -> None" 

#define VFS_xDlClose_USAGE "VFS.xDlClose(handle: int) -> None"

#define VFS_xDlClose_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(handle), void *)); \
} while(0)


#define  VFS_xDlError_DOC "xDlError($self)\n--\n\nVFS.xDlError() -> str\n\n" \
"Return an error string describing the last error of\n" \
":meth:`~VFS.xDlOpen` or :meth:`~VFS.xDlSym` (ie they returned\n" \
"zero/NULL). If you do not supply this routine then SQLite provides\n" \
"a generic message. To implement this method, catch exceptions in\n" \
":meth:`~VFS.xDlOpen` or :meth:`~VFS.xDlSym`, turn them into\n" \
"strings, save them, and return them in this routine.  If you have\n" \
"an error in this routine or return None then SQLite's generic\n" \
"message will be used.\n" 

#define  VFS_xDlOpen_DOC "xDlOpen($self,filename)\n--\n\nVFS.xDlOpen(filename: str) -> int\n\n" \
"Load the shared library. You should return a number which will be\n" \
"treated as a void pointer at the C level. On error you should\n" \
"return 0 (NULL). The number is passed as is to\n" \
":meth:`~VFS.xDlSym`/:meth:`~VFS.xDlClose` so it can represent\n" \
"anything that is convenient for you (eg an index into an\n" \
"array). You can use ctypes to load a library::\n" \
"\n" \
"  def xDlOpen(name):\n" \
"     return ctypes.cdll.LoadLibrary(name)._handle\n" 

#define VFS_xDlOpen_USAGE "VFS.xDlOpen(filename: str) -> int"

#define VFS_xDlOpen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
} while(0)


#define  VFS_xDlSym_DOC "xDlSym($self,handle,symbol)\n--\n\nVFS.xDlSym(handle: int, symbol: str) -> int\n\n" \
"Returns the address of the named symbol which will be called by\n" \
"SQLite. On error you should return 0 (NULL). You can use ctypes::\n" \
"\n" \
"  def xDlSym(ptr, name):\n" \
"     return _ctypes.dlsym (ptr, name)  # Linux/Unix/Mac etc (note leading underscore)\n" \
"     return ctypes.win32.kernel32.GetProcAddress (ptr, name)  # Windows\n" \
"\n" \
":param handle: The value returned from an earlier :meth:`~VFS.xDlOpen` call\n" \
":param symbol: A string\n" 

#define VFS_xDlSym_handle_MSG  "argument 'handle' of VFS.xDlSym(handle: int, symbol: str) -> int" 

#define VFS_xDlSym_USAGE "VFS.xDlSym(handle: int, symbol: str) -> int"

#define VFS_xDlSym_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(handle), void *)); \
  assert(__builtin_types_compatible_p(typeof(symbol), const char *)); \
} while(0)


#define  VFS_xFullPathname_DOC "xFullPathname($self,name)\n--\n\nVFS.xFullPathname(name: str) -> str\n\n" \
"Return the absolute pathname for name.  You can use ``os.path.abspath`` to do this.\n" 

#define VFS_xFullPathname_USAGE "VFS.xFullPathname(name: str) -> str"

#define VFS_xFullPathname_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xGetLastError_DOC "xGetLastError($self)\n--\n\nVFS.xGetLastError() -> Tuple[int, str]\n\n" \
"This method is to return an integer error code and (optional) text describing\n" \
"the last error that happened in this thread.\n" \
"\n" \
".. note:: SQLite 3.12 changed the semantics in an incompatible way from\n" \
"     earlier versions.  You will need to rewrite earlier implementations.\n" 

#define  VFS_xGetSystemCall_DOC "xGetSystemCall($self,name)\n--\n\nVFS.xGetSystemCall(name: str) -> Optional[int]\n\n" \
"Returns a pointer for the current method implementing the named\n" \
"system call.  Return None if the call does not exist.\n" 

#define VFS_xGetSystemCall_USAGE "VFS.xGetSystemCall(name: str) -> Optional[int]"

#define VFS_xGetSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xNextSystemCall_DOC "xNextSystemCall($self,name)\n--\n\nVFS.xNextSystemCall(name: Optional[str]) -> Optional[str]\n\n" \
"This method is repeatedly called to iterate over all of the system\n" \
"calls in the vfs.  When called with None you should return the\n" \
"name of the first system call.  In subsequent calls return the\n" \
"name after the one passed in.  If name is the last system call\n" \
"then return None.\n" \
"\n" \
".. note::\n" \
"\n" \
"  Because of internal SQLite implementation semantics memory will\n" \
"  be leaked on each call to this function.  Consequently you\n" \
"  should build up the list of call names once rather than\n" \
"  repeatedly doing it.\n" 

#define VFS_xNextSystemCall_USAGE "VFS.xNextSystemCall(name: Optional[str]) -> Optional[str]"

#define VFS_xNextSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xOpen_DOC "xOpen($self,name,flags)\n--\n\nVFS.xOpen(name: Optional[Union[str,URIFilename]], flags: List[int,int]) -> VFSFile\n\n" \
"This method should return a new file object based on name.  You\n" \
"can return a :class:`VFSFile` from a completely different VFS.\n" \
"\n" \
":param name: File to open.  Note that *name* may be *None* in which\n" \
"    case you should open a temporary file with a name of your\n" \
"    choosing.  May be an instance of :class:`URIFilename`.\n" \
"\n" \
":param flags: A list of two integers ``[inputflags,\n" \
"  outputflags]``.  Each integer is one or more of the `open flags\n" \
"  <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ binary orred\n" \
"  together.  The ``inputflags`` tells you what SQLite wants.  For\n" \
"  example *SQLITE_OPEN_DELETEONCLOSE* means the file should\n" \
"  be automatically deleted when closed.  The ``outputflags``\n" \
"  describes how you actually did open the file.  For example if you\n" \
"  opened it read only then *SQLITE_OPEN_READONLY* should be\n" \
"  set.\n" 

#define VFS_xOpen_name_MSG  "argument 'name' of VFS.xOpen(name: Optional[Union[str,URIFilename]], flags: List[int,int]) -> VFSFile" 
#define VFS_xOpen_flags_MSG  "argument 'flags' of VFS.xOpen(name: Optional[Union[str,URIFilename]], flags: List[int,int]) -> VFSFile" 

#define VFS_xOpen_USAGE "VFS.xOpen(name: Optional[Union[str,URIFilename]], flags: List[int,int]) -> VFSFile"

#define VFS_xOpen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), PyObject *)); \
} while(0)


#define  VFS_xRandomness_DOC "xRandomness($self,numbytes)\n--\n\nVFS.xRandomness(numbytes: int) -> bytes\n\n" \
"This method is called once when SQLite needs to seed the random\n" \
"number generator. It is called on the default VFS only. It is not\n" \
"called again, even across :meth:`apsw.shutdown` calls.  You can\n" \
"return less than the number of bytes requested including None. If\n" \
"you return more then the surplus is ignored.\n" 

#define VFS_xRandomness_USAGE "VFS.xRandomness(numbytes: int) -> bytes"

#define VFS_xRandomness_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(numbytes), int)); \
} while(0)


#define  VFS_xSetSystemCall_DOC "xSetSystemCall($self,name,pointer)\n--\n\nVFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool\n\n" \
"Change a system call used by the VFS.  This is useful for testing\n" \
"and some other scenarios such as sandboxing.\n" \
"\n" \
":param name: The string name of the system call\n" \
"\n" \
":param pointer: A pointer provided as an int.  There is no\n" \
"  reference counting or other memory tracking of the pointer.  If\n" \
"  you provide one you need to ensure it is around for the lifetime\n" \
"  of this and any other related VFS.\n" \
"\n" \
"Raise an exception to return an error.  If the system call does\n" \
"not exist then raise :exc:`NotFoundError`.\n" \
"\n" \
"If `name` is None, then all systemcalls are reset to their defaults.  This\n" \
"behaviour is not documented.\n" \
"\n" \
":returns: True if the system call was set.  False if the system\n" \
"  call is not known.\n" 

#define VFS_xSetSystemCall_pointer_MSG  "argument 'pointer' of VFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool" 

#define VFS_xSetSystemCall_USAGE "VFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool"

#define VFS_xSetSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define  VFS_xSleep_DOC "xSleep($self,microseconds)\n--\n\nVFS.xSleep(microseconds: int) -> int\n\n" \
"Pause execution of the thread for at least the specified number of\n" \
"microseconds (millionths of a second).  This routine is typically called from the busy handler.\n" \
"\n" \
":returns: How many microseconds you actually requested the\n" \
"  operating system to sleep for. For example if your operating\n" \
"  system sleep call only takes seconds then you would have to have\n" \
"  rounded the microseconds number up to the nearest second and\n" \
"  should return that rounded up value.\n" 

#define VFS_xSleep_USAGE "VFS.xSleep(microseconds: int) -> int"

#define VFS_xSleep_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(microseconds), int)); \
} while(0)


#define  Zeroblob_class_DOC "If you want to insert a blob into a row, you previously needed to\n" \
"supply the entire blob in one go.  To read just one byte also\n" \
"required retrieving the blob in its entirety. For example to insert\n" \
"a 100MB file you would have done::\n" \
"\n" \
"   largedata=open(\"largefile\", \"rb\").read()\n" \
"   cur.execute(\"insert into foo values(?)\", (largedata,))\n" \
"\n" \
"SQLite 3.5 allowed for incremental Blob I/O so you can read and\n" \
"write blobs in small amounts.  You cannot change the size of a blob\n" \
"so you need to reserve space which you do through zeroblob which\n" \
"creates a blob of the specified size but full of zero bytes.  For\n" \
"example you would reserve space for your 100MB one of these two\n" \
"ways::\n" \
"\n" \
"  cur.execute(\"insert into foo values(zeroblob(100000000))\")\n" \
"  cur.execute(\"insert into foo values(?),\n" \
"               (apsw.zeroblob(100000000),))\n" \
"\n" \
"This class is used for the second way.  Once a blob exists in the\n" \
"database, you then use the :class:`Blob` class to read and write its\n" \
"contents.\n" 

#define  Zeroblob_init_DOC "__init__($self,size)\n--\n\nzeroblob.__init__(size: int)\n\n" \
":param size: Number of zeroed bytes to create\n" 

#define Zeroblob_init_USAGE "zeroblob.__init__(size: int)"

#define Zeroblob_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(size), long long)); \
} while(0)


#define  Zeroblob_length_DOC "length($self)\n--\n\nzeroblob.length() -> int\n\n" \
"Size of zero blob in bytes.\n" 

#define  AbortError_exc_DOC "*SQLITE_ABORT*. Callback routine requested an abort.\n" 

#define  AuthError_exc_DOC "*SQLITE_AUTH*.  :attr:`Authorization <Connection.authorizer>` denied.\n" 

#define  BindingsError_exc_DOC "There are several causes for this exception.  When using tuples, an incorrect number of bindings where supplied::\n" \
"\n" \
"   cursor.execute(\"select ?,?,?\", (1,2))     # too few bindings\n" \
"   cursor.execute(\"select ?,?,?\", (1,2,3,4)) # too many bindings\n" \
"\n" \
"You are using named bindings, but not all bindings are named.  You should either use entirely the\n" \
"named style or entirely numeric (unnamed) style::\n" \
"\n" \
"   cursor.execute(\"select * from foo where x=:name and y=?\")\n" \
"\n" \
".. note::\n" \
"\n" \
"   It is not considered an error to have missing keys in a dictionary. For example this is perfectly valid::\n" \
"\n" \
"        cursor.execute(\"insert into foo values($a,:b,$c)\", {'a': 1})\n" \
"\n" \
"   *b* and *c* are not in the dict.  For missing keys, None/NULL\n" \
"   will be used. This is so you don't have to add lots of spurious\n" \
"   values to the supplied dict. If your schema requires every column\n" \
"   have a value, then SQLite will generate an error due to some\n" \
"   values being None/NULL so that case will be caught.\n" 

#define  BusyError_exc_DOC "*SQLITE_BUSY*.  The database file is locked.  Use\n" \
":meth:`Connection.setbusytimeout` to change how long SQLite waits\n" \
"for the database to be unlocked or :meth:`Connection.setbusyhandler`\n" \
"to use your own handler.\n" 

#define  CantOpenError_exc_DOC "*SQLITE_CANTOPEN*.  Unable to open the database file.\n" 

#define  ConnectionClosedError_exc_DOC "You have called :meth:`Connection.close` and then continued to use\n" \
"the :class:`Connection` or associated :class:`cursors <Cursor>`.\n" 

#define  ConnectionNotClosedError_exc_DOC "This exception is no longer generated.  It was required in earlier\n" \
"releases due to constraints in threading usage with SQLite.\n" 

#define  ConstraintError_exc_DOC "*SQLITE_CONSTRAINT*. Abort due to `constraint\n" \
"<https://sqlite.org/lang_createtable.html>`_ violation.  This\n" \
"would happen if the schema required a column to be within a specific\n" \
"range.  If you have multiple constraints, you `can't tell\n" \
"<https://sqlite.org/src/tktview/23b212820161c6599cbf414aa99bf8a5bfa5e7a3>`__\n" \
"which one was the cause.\n" 

#define  CorruptError_exc_DOC "*SQLITE_CORRUPT*.  The database disk image appears to be a\n" \
"SQLite database but the values inside are inconsistent.\n" 

#define  CursorClosedError_exc_DOC "You have called :meth:`Cursor.close` and then tried to use the cursor.\n" 

#define  EmptyError_exc_DOC "*SQLITE_EMPTY*. Database is completely empty.\n" 

#define  Error_exc_DOC "  This is the base for APSW exceptions.\n" \
"\n" \
".. attribute:: Error.result\n" \
"\n" \
"         For exceptions corresponding to `SQLite error codes\n" \
"         <https://sqlite.org/c3ref/c_abort.html>`_ codes this attribute\n" \
"         is the numeric error code.\n" \
"\n" \
".. attribute:: Error.extendedresult\n" \
"\n" \
"         APSW runs with `extended result codes\n" \
"         <https://sqlite.org/rescode.html>`_ turned on.\n" \
"         This attribute includes the detailed code.\n" \
"\n" \
".. attribute:: Error.error_offset\n" \
"\n" \
"        The location of the error in the SQL when encoded in UTF-8.\n" \
"        The value is from `sqlite3_error_offset\n" \
"        <https://www.sqlite.org/c3ref/errcode.html>`__.\n" 

#define  ExecTraceAbort_exc_DOC "The :ref:`execution tracer <executiontracer>` returned False so\n" \
"execution was aborted.\n" 

#define  ExecutionCompleteError_exc_DOC "A statement is complete but you try to run it more anyway!\n" 

#define  ExtensionLoadingError_exc_DOC "An error happened loading an `extension\n" \
"<https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_.\n" 

#define  ForkingViolationError_exc_DOC "See :meth:`apsw.fork_checker`.\n" 

#define  FormatError_exc_DOC "*SQLITE_FORMAT*. (No longer used) `Auxiliary database <https://sqlite.org/lang_attach.html>`_ format error.\n" 

#define  FullError_exc_DOC "*SQLITE_FULL*.  The disk appears to be full.\n" 

#define  IOError_exc_DOC "*SQLITE_IOERR*.  Some kind of disk I/O error occurred.  The\n" \
":ref:`extended error code <exceptions>` will give more detail.\n" 

#define  IncompleteExecutionError_exc_DOC "You have tried to start a new SQL execute call before executing all\n" \
"the previous ones. See the :ref:`execution model <executionmodel>`\n" \
"for more details.\n" 

#define  InternalError_exc_DOC "*SQLITE_INTERNAL*. (No longer used) Internal logic error in SQLite.\n" 

#define  InterruptError_exc_DOC "*SQLITE_INTERRUPT*.  Operation terminated by\n" \
"`sqlite3_interrupt <https://sqlite.org/c3ref/interrupt.html>`_ -\n" \
"use :meth:`Connection.interrupt`.\n" 

#define  LockedError_exc_DOC "*SQLITE_LOCKED*.  A table in the database is locked.\n" 

#define  MismatchError_exc_DOC "*SQLITE_MISMATCH*. Data type mismatch.  For example a rowid\n" \
"or integer primary key must be an integer.\n" 

#define  MisuseError_exc_DOC "*SQLITE_MISUSE*.  SQLite library used incorrectly - typically similar to *ValueError* in Python.  Examples include not\n" \
"having enough flags when opening a connection (eg not including a READ or WRITE flag), or out of spec such as registering\n" \
"a function with more than 127 parameters.\n" 

#define  NoLFSError_exc_DOC "*SQLITE_NOLFS*.  SQLite has attempted to use a feature not\n" \
"supported by the operating system such as `large file support\n" \
"<http://en.wikipedia.org/wiki/Large_file_support>`_.\n" 

#define  NoMemError_exc_DOC "*SQLITE_NOMEM*.  A memory allocation failed.\n" 

#define  NotADBError_exc_DOC "*SQLITE_NOTADB*.  File opened that is not a database file.\n" \
"SQLite has a header on database files to verify they are indeed\n" \
"SQLite databases.\n" 

#define  NotFoundError_exc_DOC "*SQLITE_NOTFOUND*. Returned when various internal items were\n" \
"not found such as requests for non-existent system calls or file\n" \
"controls.\n" 

#define  PermissionsError_exc_DOC "*SQLITE_PERM*. Access permission denied by the operating system, or parts of the database are readonly such as a cursor.\n" 

#define  ProtocolError_exc_DOC "*SQLITE_PROTOCOL*. (No longer used) Database lock protocol error.\n" 

#define  RangeError_exc_DOC "*SQLITE_RANGE*.  (Cannot be generated using APSW).  2nd parameter to `sqlite3_bind <https://sqlite.org/c3ref/bind_blob.html>`_ out of range\n" 

#define  ReadOnlyError_exc_DOC "*SQLITE_READONLY*. Attempt to write to a readonly database.\n" 

#define  SQLError_exc_DOC "*SQLITE_ERROR*.  This error is documented as a bad SQL query\n" \
"or missing database, but is also returned for a lot of other\n" \
"situations.  It is the default error code unless there is a more\n" \
"specific one.\n" 

#define  SchemaChangeError_exc_DOC "*SQLITE_SCHEMA*.  The database schema changed.  A\n" \
":meth:`prepared statement <Cursor.execute>` becomes invalid\n" \
"if the database schema was changed.  Behind the scenes SQLite\n" \
"reprepares the statement.  Another or the same :class:`Connection`\n" \
"may change the schema again before the statement runs.  SQLite will\n" \
"attempt up to 5 times before giving up and returning this error.\n" 

#define  ThreadingViolationError_exc_DOC "You have used an object concurrently in two threads. For example you\n" \
"may try to use the same cursor in two different threads at the same\n" \
"time, or tried to close the same connection in two threads at the\n" \
"same time.\n" \
"\n" \
"You can also get this exception by using a cursor as an argument to\n" \
"itself (eg as the input data for :meth:`Cursor.executemany`).\n" \
"Cursors can only be used for one thing at a time.\n" 

#define  TooBigError_exc_DOC "*SQLITE_TOOBIG*.  String or BLOB exceeds size limit.  You can\n" \
"change the limits using :meth:`Connection.limit`.\n" 

#define  VFSFileClosedError_exc_DOC "The VFS file is closed so the operation cannot be performed.\n" 

#define  VFSNotImplementedError_exc_DOC "A call cannot be made to an inherited :ref:`VFS` method as the VFS\n" \
"does not implement the method.\n" 

