/* This file is generated by rst2docstring */

#ifndef __GNUC__
#define __builtin_types_compatible_p(x,y) (1)
#endif

#define  Apsw_apswversion_DOC "apswversion($self)\n--\n\napsw.apswversion() -> str\n\n" \
"Returns the APSW version.\n" 

#define  Apsw_complete_DOC "complete($self,statement)\n--\n\napsw.complete(statement: str) -> bool\n\n" \
"Returns True if the input string comprises one or more complete SQL\n" \
"statements by looking for an unquoted trailing semi-colon.\n" \
"\n" \
"An example use would be if you were prompting the user for SQL\n" \
"statements and needed to know if you had a whole statement, or\n" \
"needed to ask for another line::\n" \
"\n" \
"  statement = input(\"SQL> \")\n" \
"  while not apsw.complete(statement):\n" \
"     more = input(\"  .. \")\n" \
"     statement = statement + \"\\n\" + more\n" \
"\n" \
"Calls: `sqlite3_complete <https://sqlite.org/c3ref/complete.html>`__\n" 

#define Apsw_complete_USAGE "apsw.complete(statement: str) -> bool"

#define Apsw_complete_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statement), const char *)); \
} while(0)


#define  Apsw_config_DOC "config($self,op,*args)\n--\n\napsw.config(op: int, *args: Any) -> None\n\n" \
":param op: A `configuration operation <https://sqlite.org/c3ref/c_config_chunkalloc.html>`_\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
"Many operations don't make sense from a Python program.  The\n" \
"following configuration operations are supported: SQLITE_CONFIG_LOG,\n" \
"SQLITE_CONFIG_SINGLETHREAD, SQLITE_CONFIG_MULTITHREAD,\n" \
"SQLITE_CONFIG_SERIALIZED, SQLITE_CONFIG_URI, SQLITE_CONFIG_MEMSTATUS,\n" \
"SQLITE_CONFIG_COVERING_INDEX_SCAN, SQLITE_CONFIG_PCACHE_HDRSZ,\n" \
"SQLITE_CONFIG_PMASZ, and SQLITE_CONFIG_STMTJRNL_SPILL.\n" \
"\n" \
"See :ref:`tips <diagnostics_tips>` for an example of how to receive\n" \
"log messages (SQLITE_CONFIG_LOG)\n" \
"\n" \
"Calls: `sqlite3_config <https://sqlite.org/c3ref/config.html>`__\n" 

#define  Apsw_enablesharedcache_DOC "enablesharedcache($self,enable)\n--\n\napsw.enablesharedcache(enable: bool) -> None\n\n" \
"If you use the same :class:`Connection` across threads or use\n" \
"multiple :class:`connections <Connection>` accessing the same file,\n" \
"then SQLite can `share the cache between them\n" \
"<https://sqlite.org/sharedcache.html>`_.  It is :ref:`not\n" \
"recommended <sharedcache>` that you use this.\n" \
"\n" \
"Calls: `sqlite3_enable_shared_cache <https://sqlite.org/c3ref/enable_shared_cache.html>`__\n" 

#define Apsw_enablesharedcache_USAGE "apsw.enablesharedcache(enable: bool) -> None"

#define Apsw_enablesharedcache_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(enable), int)); \
} while(0)


#define  Apsw_exceptionfor_DOC "exceptionfor($self,code)\n--\n\napsw.exceptionfor(code: int) -> Exception\n\n" \
"If you would like to raise an exception that corresponds to a\n" \
"particular SQLite `error code\n" \
"<https://sqlite.org/c3ref/c_abort.html>`_ then call this function.\n" \
"It also understands `extended error codes\n" \
"<https://sqlite.org/c3ref/c_ioerr_access.html>`_.\n" \
"\n" \
"For example to raise `SQLITE_IOERR_ACCESS <https://sqlite.org/c3ref/c_ioerr_access.html>`_::\n" \
"\n" \
"  raise apsw.exceptionfor(apsw.SQLITE_IOERR_ACCESS)\n" 

#define Apsw_exceptionfor_USAGE "apsw.exceptionfor(code: int) -> Exception"

#define Apsw_exceptionfor_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(code), int)); \
} while(0)


#define  Apsw_fork_checker_DOC "fork_checker($self)\n--\n\napsw.fork_checker() -> None\n\n" \
"**Note** This method is not available on Windows as it does not\n" \
"support the fork system call.\n" \
"\n" \
"SQLite does not allow the use of database connections across `forked\n" \
"<http://en.wikipedia.org/wiki/Fork_(operating_system)>`__ processes\n" \
"(see the `SQLite FAQ Q6 <https://sqlite.org/faq.html#q6>`__).\n" \
"(Forking creates a child process that is a duplicate of the parent\n" \
"including the state of all data structures in the program.  If you\n" \
"do this to SQLite then parent and child would both consider\n" \
"themselves owners of open databases and silently corrupt each\n" \
"other's work and interfere with each other's locks.)\n" \
"\n" \
"One example of how you may end up using fork is if you use the\n" \
"`multiprocessing module\n" \
"<http://docs.python.org/library/multiprocessing.html>`__ which uses\n" \
"fork to make child processes.\n" \
"\n" \
"If you do use fork or multiprocessing on a platform that supports\n" \
"fork then you **must** ensure database connections and their objects\n" \
"(cursors, backup, blobs etc) are not used in the parent process, or\n" \
"are all closed before calling fork or starting a `Process\n" \
"<http://docs.python.org/library/multiprocessing.html#process-and-exceptions>`__.\n" \
"(Note you must call close to ensure the underlying SQLite objects\n" \
"are closed.  It is also a good idea to call `gc.collect(2)\n" \
"<http://docs.python.org/library/gc.html#gc.collect>`__ to ensure\n" \
"anything you may have missed is also deallocated.)\n" \
"\n" \
"Once you run this method, extra checking code is inserted into\n" \
"SQLite's mutex operations (at a very small performance penalty) that\n" \
"verifies objects are not used across processes.  You will get a\n" \
":exc:`ForkingViolationError` if you do so.  Note that due to the way\n" \
"Python's internals work, the exception will be delivered to\n" \
"`sys.excepthook` in addition to the normal exception mechanisms and\n" \
"may be reported by Python after the line where the issue actually\n" \
"arose.  (Destructors of objects you didn't close also run between\n" \
"lines.)\n" \
"\n" \
"You should only call this method as the first line after importing\n" \
"APSW, as it has to shutdown and re-initialize SQLite.  If you have\n" \
"any SQLite objects already allocated when calling the method then\n" \
"the program will later crash.  The recommended use is to use the fork\n" \
"checking as part of your test suite.\n" 

#define  Apsw_format_sql_value_DOC "format_sql_value($self,value)\n--\n\napsw.format_sql_value(value: SQLiteValue) -> str\n\n" \
"Returns a Python string representing the supplied value in SQL syntax.\n" 

#define  Apsw_initialize_DOC "initialize($self)\n--\n\napsw.initialize() -> None\n\n" \
"It is unlikely you will want to call this method as SQLite automatically initializes.\n" \
"\n" \
"Calls: `sqlite3_initialize <https://sqlite.org/c3ref/initialize.html>`__\n" 

#define  Apsw_log_DOC "log($self,errorcode,message)\n--\n\napsw.log(errorcode: int, message: str) -> None\n\n" \
"Calls the SQLite logging interface.  Note that you must format the\n" \
"message before passing it to this method::\n" \
"\n" \
"    apsw.log(apsw.SQLITE_NOMEM, f\"Need { needed } bytes of memory\")\n" \
"\n" \
"See :ref:`tips <diagnostics_tips>` for an example of how to\n" \
"receive log messages.\n" \
"\n" \
"Calls: `sqlite3_log <https://sqlite.org/c3ref/log.html>`__\n" 

#define Apsw_log_USAGE "apsw.log(errorcode: int, message: str) -> None"

#define Apsw_log_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(errorcode), int)); \
  assert(__builtin_types_compatible_p(typeof(message), const char *)); \
} while(0)


#define  Apsw_memoryhighwater_DOC "memoryhighwater($self,reset=False)\n--\n\napsw.memoryhighwater(reset: bool = False) -> int\n\n" \
"Returns the maximum amount of memory SQLite has used.  If *reset* is\n" \
"True then the high water mark is reset to the current value.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`status`\n" \
"\n" \
"Calls: `sqlite3_memory_highwater <https://sqlite.org/c3ref/memory_highwater.html>`__\n" 

#define Apsw_memoryhighwater_USAGE "apsw.memoryhighwater(reset: bool = False) -> int"

#define Apsw_memoryhighwater_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Apsw_memoryused_DOC "memoryused($self)\n--\n\napsw.memoryused() -> int\n\n" \
"Returns the amount of memory SQLite is currently using.\n" \
"\n" \
".. seealso::\n" \
"  :meth:`status`\n" \
"\n" \
"Calls: `sqlite3_memory_used <https://sqlite.org/c3ref/memory_highwater.html>`__\n" 

#define  Apsw_randomness_DOC "randomness($self,amount)\n--\n\napsw.randomness(amount: int)  -> bytes\n\n" \
"Gets random data from SQLite's random number generator.\n" \
"\n" \
":param amount: How many bytes to return\n" \
"\n" \
"Calls: `sqlite3_randomness <https://sqlite.org/c3ref/randomness.html>`__\n" 

#define Apsw_randomness_USAGE "apsw.randomness(amount: int)  -> bytes"

#define Apsw_randomness_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define  Apsw_releasememory_DOC "releasememory($self,amount)\n--\n\napsw.releasememory(amount: int) -> int\n\n" \
"Requests SQLite try to free *amount* bytes of memory.  Returns how\n" \
"many bytes were freed.\n" \
"\n" \
"Calls: `sqlite3_release_memory <https://sqlite.org/c3ref/release_memory.html>`__\n" 

#define Apsw_releasememory_USAGE "apsw.releasememory(amount: int) -> int"

#define Apsw_releasememory_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
} while(0)


#define  Apsw_shutdown_DOC "shutdown($self)\n--\n\napsw.shutdown() -> None\n\n" \
"It is unlikely you will want to call this method and there is no\n" \
"need to do so.  It is a **really** bad idea to call it unless you\n" \
"are absolutely sure all :class:`connections <Connection>`,\n" \
":class:`blobs <blob>`, :class:`cursors <Cursor>`, :class:`vfs <VFS>`\n" \
"etc have been closed, deleted and garbage collected.\n" \
"\n" \
"Calls: `sqlite3_shutdown <https://sqlite.org/c3ref/initialize.html>`__\n" 

#define  Apsw_softheaplimit_DOC "softheaplimit($self,limit)\n--\n\napsw.softheaplimit(limit: int) -> int\n\n" \
"Requests SQLite try to keep memory usage below *amount* bytes and\n" \
"returns the previous limit.\n" \
"\n" \
"Calls: `sqlite3_soft_heap_limit64 <https://sqlite.org/c3ref/hard_heap_limit64.html>`__\n" 

#define Apsw_softheaplimit_USAGE "apsw.softheaplimit(limit: int) -> int"

#define Apsw_softheaplimit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(limit), long long)); \
} while(0)


#define  Apsw_sqlite3_sourceid_DOC "sqlite3_sourceid($self)\n--\n\napsw.sqlite3_sourceid() -> str\n\n" \
"Returns the exact checkin information for the SQLite 3 source\n" \
"being used.\n" \
"\n" \
"Calls: `sqlite3_sourceid <https://sqlite.org/c3ref/libversion.html>`__\n" 

#define  Apsw_sqlitelibversion_DOC "sqlitelibversion($self)\n--\n\napsw.sqlitelibversion() -> str\n\n" \
"Returns the version of the SQLite library.  This value is queried at\n" \
"run time from the library so if you use shared libraries it will be\n" \
"the version in the shared library.\n" \
"\n" \
"Calls: `sqlite3_libversion <https://sqlite.org/c3ref/libversion.html>`__\n" 

#define  Apsw_status_DOC "status($self,op,reset=False)\n--\n\napsw.status(op: int, reset: bool = False) -> Tuple[int, int]\n\n" \
"Returns current and highwater measurements.\n" \
"\n" \
":param op: A `status parameter <https://sqlite.org/c3ref/c_status_malloc_size.html>`_\n" \
":param reset: If *True* then the highwater is set to the current value\n" \
":returns: A tuple of current value and highwater value\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Status example <example-status>`\n" \
"\n" \
"Calls: `sqlite3_status64 <https://sqlite.org/c3ref/status.html>`__\n" 

#define Apsw_status_USAGE "apsw.status(op: int, reset: bool = False) -> Tuple[int, int]"

#define Apsw_status_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Apsw_vfsnames_DOC "vfsnames($self)\n--\n\napsw.vfsnames() -> List[str]\n\n" \
"Returns a list of the currently installed :ref:`vfs <vfs>`.  The first\n" \
"item in the list is the default vfs.\n" 

#define  Backup_close_DOC "close($self,force=False)\n--\n\nBackup.close(force: bool = False) -> None\n\n" \
"Does the same thing as :meth:`~backup.finish`.  This extra api is\n" \
"provided to give the same api as other APSW objects such as\n" \
":meth:`Connection.close`, :meth:`blob.close` and\n" \
":meth:`Cursor.close`.  It is safe to call this method multiple\n" \
"times.\n" \
"\n" \
":param force: If true then any exceptions are ignored.\n" 

#define Backup_close_USAGE "Backup.close(force: bool = False) -> None"

#define Backup_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Backup_done_DOC ":type: bool\n" \
"\n" \
"A boolean that is True if the copy completed in the last call to :meth:`~backup.step`.\n" 

#define  Backup_enter_DOC "__enter__($self)\n--\n\nBackup.__enter__() -> Backup\n\n" \
"You can use the backup object as a `context manager\n" \
"<http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  The :meth:`~backup.__exit__` method ensures that backup\n" \
"is :meth:`finished <backup.finish>`.\n" 

#define  Backup_exit_DOC "__exit__($self,etype,evalue,etraceback)\n--\n\nBackup.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[TracebackType]) -> Literal[False]\n\n" \
"Implements context manager in conjunction with :meth:`~backup.__enter__` ensuring\n" \
"that the copy is :meth:`finished <backup.finish>`.\n" 

#define Backup_exit_USAGE "Backup.__exit__(etype: Optional[type[BaseException]], evalue: Optional[BaseException], etraceback: Optional[TracebackType]) -> Literal[False]"

#define Backup_exit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(etype), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(evalue), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(etraceback), PyObject *)); \
} while(0)


#define  Backup_finish_DOC "finish($self)\n--\n\nBackup.finish() -> None\n\n" \
"Completes the copy process.  If all pages have been copied then the\n" \
"transaction is committed on the destination database, otherwise it\n" \
"is rolled back.  This method must be called for your backup to take\n" \
"effect.  The backup object will always be finished even if there is\n" \
"an exception.  It is safe to call this method multiple times.\n" \
"\n" \
"Calls: `sqlite3_backup_finish <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupfinish>`__\n" 

#define  Backup_init_DOC "__init__($self)\n--\n\nBackup.__init__() -> None\n\n" \
"You create a backup instance by calling :meth:`Connection.backup`.\n" 

#define  Backup_pagecount_DOC ":type: int\n" \
"\n" \
"Read only. How many pages were in the source database after the last\n" \
"step.  If you haven't called :meth:`~backup.step` or the backup\n" \
"object has been :meth:`finished <backup.finish>` then zero is\n" \
"returned.\n" \
"\n" \
"Calls: `sqlite3_backup_pagecount <https://sqlite.org/c3ref/backup_finish.html#sqlite3backuppagecount>`__\n" 

#define  Backup_remaining_DOC ":type: int\n" \
"\n" \
"Read only. How many pages were remaining to be copied after the last\n" \
"step.  If you haven't called :meth:`~backup.step` or the backup\n" \
"object has been :meth:`finished <backup.finish>` then zero is\n" \
"returned.\n" \
"\n" \
"Calls: `sqlite3_backup_remaining <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupremaining>`__\n" 

#define  Backup_step_DOC "step($self,npages=-1)\n--\n\nBackup.step(npages: int = -1) -> bool\n\n" \
"Copies *npages* pages from the source to destination database.  The source database is locked during the copy so\n" \
"using smaller values allows other access to the source database.  The destination database is always locked until the\n" \
"backup object is :meth:`finished <backup.finish>`.\n" \
"\n" \
":param npages: How many pages to copy. If the parameter is omitted\n" \
"   or negative then all remaining pages are copied. The default page\n" \
"   size is 1024 bytes (1kb) which can be changed before database\n" \
"   creation using a `pragma\n" \
"   <https://sqlite.org/pragma.html#modify>`_.\n" \
"\n" \
"This method may throw a :exc:`BusyError` or :exc:`LockedError` if\n" \
"unable to lock the source database.  You can catch those and try\n" \
"again.\n" \
"\n" \
":returns: True if this copied the last remaining outstanding pages, else false.  This is the same value as :attr:`~backup.done`\n" \
"\n" \
"Calls: `sqlite3_backup_step <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupstep>`__\n" 

#define Backup_step_USAGE "Backup.step(npages: int = -1) -> bool"

#define Backup_step_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(npages), int)); \
  assert(npages == (-1)); \
} while(0)


#define  Blob_close_DOC "close($self,force=False)\n--\n\nBlob.close(force: bool = False) -> None\n\n" \
"Closes the blob.  Note that even if an error occurs the blob is\n" \
"still closed.\n" \
"\n" \
".. note::\n" \
"\n" \
"   In some cases errors that technically occurred in the\n" \
"   :meth:`~blob.read` and :meth:`~blob.write` routines may not be\n" \
"   reported until close is called.  Similarly errors that occurred\n" \
"   in those methods (eg calling :meth:`~blob.write` on a read-only\n" \
"   blob) may also be re-reported in :meth:`~blob.close`.  (This\n" \
"   behaviour is what the underlying SQLite APIs do - it is not APSW\n" \
"   doing it.)\n" \
"\n" \
"It is okay to call :meth:`~blob.close` multiple times.\n" \
"\n" \
":param force: Ignores any errors during close.\n" \
"\n" \
"Calls: `sqlite3_blob_close <https://sqlite.org/c3ref/blob_close.html>`__\n" 

#define Blob_close_USAGE "Blob.close(force: bool = False) -> None"

#define Blob_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Blob_enter_DOC "__enter__($self)\n--\n\nBlob.__enter__() -> Blob\n\n" \
"You can use a blob as a `context manager\n" \
"<http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  When you use *with* statement,\n" \
"the blob is always :meth:`closed <~blob.close>` on exit from the block, even if an\n" \
"exception occurred in the block.\n" \
"\n" \
"For example::\n" \
"\n" \
"  with connection.blobopen() as blob:\n" \
"      blob.write(\"...\")\n" \
"      res=blob.read(1024)\n" 

#define  Blob_exit_DOC "__exit__($self)\n--\n\nBlob.__exit__() -> Literal[False]\n\n" \
"Implements context manager in conjunction with\n" \
":meth:`~blob.__enter__`.  Any exception that happened in the\n" \
"*with* block is raised after closing the blob.\n" 

#define  Blob_init_DOC "__init__($self)\n--\n\nBlob.__init__() -> None\n\n" \
"This object is created by :meth:`Connection.blobopen` and provides\n" \
"access to a blob in the database.  It behaves like a Python file.\n" \
"At the C level it wraps a `sqlite3_blob\n" \
"<https://sqlite.org/c3ref/blob.html>`_.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You cannot change the size of a blob using this object. You should\n" \
"  create it with the correct size in advance either by using\n" \
"  :class:`zeroblob` or the `zeroblob()\n" \
"  <https://sqlite.org/lang_corefunc.html>`_ function.\n" \
"\n" \
"See the :ref:`example <example-blobio>`.\n" 

#define  Blob_length_DOC "length($self)\n--\n\nBlob.length() -> int\n\n" \
"Returns the size of the blob in bytes.\n" \
"\n" \
"Calls: `sqlite3_blob_bytes <https://sqlite.org/c3ref/blob_bytes.html>`__\n" 

#define  Blob_read_DOC "read($self,length=-1)\n--\n\nBlob.read(length: int = -1) -> bytes\n\n" \
"Reads amount of data requested, or till end of file, whichever is\n" \
"earlier. Attempting to read beyond the end of the blob returns an\n" \
"empty bytes in the same manner as end of file on normal file\n" \
"objects.  Negative numbers read remaining data.\n" \
"\n" \
"Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__\n" 

#define Blob_read_USAGE "Blob.read(length: int = -1) -> bytes"

#define Blob_read_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(length), int)); \
  assert(length == (-1)); \
} while(0)


#define  Blob_readinto_DOC "readinto($self,buffer,offset=0,length=-1)\n--\n\nBlob.readinto(buffer: Union[bytearray, array[Any], memoryview], offset: int = 0, length: int = -1) -> None\n\n" \
"Reads from the blob into a buffer you have supplied.  This method is\n" \
"useful if you already have a buffer like object that data is being\n" \
"assembled in, and avoids allocating results in :meth:`blob.read` and\n" \
"then copying into buffer.\n" \
"\n" \
":param buffer: A writable buffer like object.\n" \
"               There is a bytearray type that is very useful.\n" \
"               :class:`array.array` also works.\n" \
"\n" \
":param offset: The position to start writing into the buffer\n" \
"               defaulting to the beginning.\n" \
"\n" \
":param length: How much of the blob to read.  The default is the\n" \
"               remaining space left in the buffer.  Note that if\n" \
"               there is more space available than blob left then you\n" \
"               will get a :exc:`ValueError` exception.\n" \
"\n" \
"Calls: `sqlite3_blob_read <https://sqlite.org/c3ref/blob_read.html>`__\n" 

#define Blob_readinto_USAGE "Blob.readinto(buffer: Union[bytearray, array[Any], memoryview], offset: int = 0, length: int = -1) -> None"

#define Blob_readinto_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(buffer), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
  assert(offset == 0L); \
  assert(__builtin_types_compatible_p(typeof(length), long long)); \
  assert(length == -1L); \
} while(0)


#define  Blob_reopen_DOC "reopen($self,rowid)\n--\n\nBlob.reopen(rowid: int) -> None\n\n" \
"Change this blob object to point to a different row.  It can be\n" \
"faster than closing an existing blob an opening a new one.\n" \
"\n" \
"Calls: `sqlite3_blob_reopen <https://sqlite.org/c3ref/blob_reopen.html>`__\n" 

#define Blob_reopen_USAGE "Blob.reopen(rowid: int) -> None"

#define Blob_reopen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
} while(0)


#define  Blob_seek_DOC "seek($self,offset,whence=0)\n--\n\nBlob.seek(offset: int, whence: int = 0) -> None\n\n" \
"Changes current position to *offset* biased by *whence*.\n" \
"\n" \
":param offset: New position to seek to.  Can be positive or negative number.\n" \
":param whence: Use 0 if *offset* is relative to the beginning of the blob,\n" \
"               1 if *offset* is relative to the current position,\n" \
"               and 2 if *offset* is relative to the end of the blob.\n" \
":raises ValueError: If the resulting offset is before the beginning (less than zero) or beyond the end of the blob.\n" 

#define Blob_seek_USAGE "Blob.seek(offset: int, whence: int = 0) -> None"

#define Blob_seek_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(offset), int)); \
  assert(__builtin_types_compatible_p(typeof(whence), int)); \
  assert(whence == (0)); \
} while(0)


#define  Blob_tell_DOC "tell($self)\n--\n\nBlob.tell() -> int\n\n" \
"Returns the current offset.\n" 

#define  Blob_write_DOC "write($self,data)\n--\n\nBlob.write(data: bytes) -> None\n\n" \
"Writes the data to the blob.\n" \
"\n" \
":param data: bytes to write\n" \
"\n" \
":raises TypeError: Wrong data type\n" \
"\n" \
":raises ValueError: If the data would go beyond the end of the blob.\n" \
"    You cannot increase the size of a blob by writing beyond the end.\n" \
"    You need to use :class:`zeroblob` to set the desired size first when\n" \
"    inserting the blob.\n" \
"\n" \
"Calls: `sqlite3_blob_write <https://sqlite.org/c3ref/blob_write.html>`__\n" 

#define Blob_write_USAGE "Blob.write(data: bytes) -> None"

#define Blob_write_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(data), Py_buffer)); \
} while(0)


#define  Connection_autovacuum_pages_DOC "autovacuum_pages($self,callable)\n--\n\nConnection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None\n\n" \
"Calls `callable` to find out how many pages to autovacuum.  The callback has 4 parameters:\n" \
"\n" \
"* Database name: str (eg \"main\")\n" \
"* Database pages: int (how many pages make up the database now)\n" \
"* Free pages: int (how many pages could be freed)\n" \
"* Page size: int (page size in bytes)\n" \
"\n" \
"Return how many pages should be freed.  Values less than zero or more than the free pages are\n" \
"treated as zero or free page count.  On error zero is returned.\n" \
"\n" \
"READ THE NOTE IN THE SQLITE DOCUMENTATION.  Calling into SQLite can result in crashes, corrupt\n" \
"databases or worse.\n" \
"\n" \
"Calls: `sqlite3_autovacuum_pages <https://sqlite.org/c3ref/autovacuum_pages.html>`__\n" 

#define Connection_autovacuum_pages_USAGE "Connection.autovacuum_pages(callable: Optional[Callable[[str, int, int, int], int]]) -> None"

#define Connection_autovacuum_pages_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_backup_DOC "backup($self,databasename,sourceconnection,sourcedatabasename)\n--\n\nConnection.backup(databasename: str, sourceconnection: Connection, sourcedatabasename: str)  -> Backup\n\n" \
"Opens a :ref:`backup object <Backup>`.  All data will be copied from source\n" \
"database to this database.\n" \
"\n" \
":param databasename: Name of the database.  This will be ``main`` for\n" \
"  the main connection and the name you specified for `attached\n" \
"  <https://sqlite.org/lang_attach.html>`_ databases.\n" \
":param sourceconnection: The :class:`Connection` to copy a database from.\n" \
":param sourcedatabasename: Name of the database in the source (eg ``main``).\n" \
"\n" \
":rtype: :class:`backup`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Backup`\n" \
"\n" \
"Calls: `sqlite3_backup_init <https://sqlite.org/c3ref/backup_finish.html#sqlite3backupinit>`__\n" 

#define Connection_backup_USAGE "Connection.backup(databasename: str, sourceconnection: Connection, sourcedatabasename: str)  -> Backup"

#define Connection_backup_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(databasename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(sourceconnection), Connection *)); \
  assert(__builtin_types_compatible_p(typeof(sourcedatabasename), const char *)); \
} while(0)


#define  Connection_blobopen_DOC "blobopen($self,database,table,column,rowid,writeable)\n--\n\nConnection.blobopen(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob\n\n" \
"Opens a blob for :ref:`incremental I/O <blobio>`.\n" \
"\n" \
":param database: Name of the database.  This will be ``main`` for\n" \
"  the main connection and the name you specified for `attached\n" \
"  <https://sqlite.org/lang_attach.html>`_ databases.\n" \
":param table: The name of the table\n" \
":param column: The name of the column\n" \
":param rowid: The id that uniquely identifies the row.\n" \
":param writeable: If True then you can read and write the blob.  If False then you can only read it.\n" \
"\n" \
":rtype: :class:`blob`\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Blob I/O example <example-blobio>`\n" \
"  * `SQLite row ids <https://sqlite.org/autoinc.html>`_\n" \
"\n" \
"Calls: `sqlite3_blob_open <https://sqlite.org/c3ref/blob_open.html>`__\n" 

#define Connection_blobopen_USAGE "Connection.blobopen(database: str, table: str, column: str, rowid: int, writeable: bool)  -> Blob"

#define Connection_blobopen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(database), const char *)); \
  assert(__builtin_types_compatible_p(typeof(table), const char *)); \
  assert(__builtin_types_compatible_p(typeof(column), const char *)); \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
  assert(__builtin_types_compatible_p(typeof(writeable), int)); \
} while(0)


#define  Connection_changes_DOC "changes($self)\n--\n\nConnection.changes() -> int\n\n" \
"Returns the number of database rows that were changed (or inserted\n" \
"or deleted) by the most recently completed INSERT, UPDATE, or DELETE\n" \
"statement.\n" \
"\n" \
"Calls: `sqlite3_changes64 <https://sqlite.org/c3ref/changes.html>`__\n" 

#define  Connection_close_DOC "close($self,force=False)\n--\n\nConnection.close(force: bool = False) -> None\n\n" \
"Closes the database.  If there are any outstanding :class:`cursors\n" \
"<Cursor>`, :class:`blobs <blob>` or :class:`backups <backup>` then\n" \
"they are closed too.  It is normally not necessary to call this\n" \
"method as the database is automatically closed when there are no\n" \
"more references.  It is ok to call the method multiple times.\n" \
"\n" \
"If your user defined functions or collations have direct or indirect\n" \
"references to the Connection then it won't be automatically garbage\n" \
"collected because of circular referencing that can't be\n" \
"automatically broken.  Calling *close* will free all those objects\n" \
"and what they reference.\n" \
"\n" \
"SQLite is designed to survive power failures at even the most\n" \
"awkward moments.  Consequently it doesn't matter if it is closed\n" \
"when the process is exited, or even if the exit is graceful or\n" \
"abrupt.  In the worst case of having a transaction in progress, that\n" \
"transaction will be rolled back by the next program to open the\n" \
"database, reverting the database to a know good state.\n" \
"\n" \
"If *force* is *True* then any exceptions are ignored.\n" \
"\n" \
"Calls: `sqlite3_close <https://sqlite.org/c3ref/close.html>`__\n" 

#define Connection_close_USAGE "Connection.close(force: bool = False) -> None"

#define Connection_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Connection_collationneeded_DOC "collationneeded($self,callable)\n--\n\nConnection.collationneeded(callable: Optional[Callable[[Connection, str], None]]) -> None\n\n" \
"*callable* will be called if a statement requires a `collation\n" \
"<http://en.wikipedia.org/wiki/Collation>`_ that hasn't been\n" \
"registered. Your callable will be passed two parameters. The first\n" \
"is the connection object. The second is the name of the\n" \
"collation. If you have the collation code available then call\n" \
":meth:`Connection.createcollation`.\n" \
"\n" \
"This is useful for creating collations on demand.  For example you\n" \
"may include the `locale <http://en.wikipedia.org/wiki/Locale>`_ in\n" \
"the collation name, but since there are thousands of locales in\n" \
"popular use it would not be useful to :meth:`prereigster\n" \
"<Connection.createcollation>` them all.  Using\n" \
":meth:`~Connection.collationneeded` tells you when you need to\n" \
"register them.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.createcollation`\n" \
"\n" \
"Calls: `sqlite3_collation_needed <https://sqlite.org/c3ref/collation_needed.html>`__\n" 

#define Connection_collationneeded_USAGE "Connection.collationneeded(callable: Optional[Callable[[Connection, str], None]]) -> None"

#define Connection_collationneeded_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_config_DOC "config($self,op,*args)\n--\n\nConnection.config(op: int, *args: int) -> int\n\n" \
":param op: A `configuration operation\n" \
"  <https://sqlite.org/c3ref/c_dbconfig_enable_fkey.html>`__\n" \
":param args: Zero or more arguments as appropriate for *op*\n" \
"\n" \
"Only optiona that take an int and return one are implemented.\n" \
"\n" \
"Calls: `sqlite3_db_config <https://sqlite.org/c3ref/db_config.html>`__\n" 

#define  Connection_createaggregatefunction_DOC "createaggregatefunction($self,name,factory,numargs=-1)\n--\n\nConnection.createaggregatefunction(name: str, factory: Optional[AggregateFactory], numargs: int = -1) -> None\n\n" \
"Registers an aggregate function.  Aggregate functions operate on all\n" \
"the relevant rows such as counting how many there are.\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param factory: The function that will be called.  Use None to delete the function.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
"\n" \
"When a query starts, the *factory* will be called and must return a tuple of 3 items:\n" \
"\n" \
"  a context object\n" \
"     This can be of any type\n" \
"\n" \
"  a step function\n" \
"     This function is called once for each row.  The first parameter\n" \
"     will be the context object and the remaining parameters will be\n" \
"     from the SQL statement.  Any value returned will be ignored.\n" \
"\n" \
"  a final function\n" \
"     This function is called at the very end with the context object\n" \
"     as a parameter.  The value returned is set as the return for\n" \
"     the function. The final function is always called even if an\n" \
"     exception was raised by the step function. This allows you to\n" \
"     ensure any resources are cleaned up.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You can register the same named function but with different\n" \
"  callables and *numargs*.  See\n" \
"  :meth:`~Connection.createscalarfunction` for an example.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <aggregate-example>`\n" \
"   * :meth:`~Connection.createscalarfunction`\n" \
"\n" \
"Calls: `sqlite3_create_function_v2 <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_createaggregatefunction_USAGE "Connection.createaggregatefunction(name: str, factory: Optional[AggregateFactory], numargs: int = -1) -> None"

#define Connection_createaggregatefunction_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(factory), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
} while(0)


#define  Connection_createcollation_DOC "createcollation($self,name,callback)\n--\n\nConnection.createcollation(name: str, callback: Optional[Callable[[str, str], int]]) -> None\n\n" \
"You can control how SQLite sorts (termed `collation\n" \
"<http://en.wikipedia.org/wiki/Collation>`_) when giving the\n" \
"``COLLATE`` term to a `SELECT\n" \
"<https://sqlite.org/lang_select.html>`_.  For example your\n" \
"collation could take into account locale or do numeric sorting.\n" \
"\n" \
"The *callback* will be called with two items.  It should return -1\n" \
"if the first is less then the second, 0 if they are equal, and 1 if\n" \
"first is greater::\n" \
"\n" \
"   def mycollation(one, two):\n" \
"       if one < two:\n" \
"           return -1\n" \
"       if one == two:\n" \
"           return 0\n" \
"       if one > two:\n" \
"           return 1\n" \
"\n" \
"Passing None as the callback will unregister the collation.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <collation-example>`\n" \
"\n" \
"Calls: `sqlite3_create_collation_v2 <https://sqlite.org/c3ref/create_collation.html>`__\n" 

#define Connection_createcollation_USAGE "Connection.createcollation(name: str, callback: Optional[Callable[[str, str], int]]) -> None"

#define Connection_createcollation_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(callback), PyObject *)); \
} while(0)


#define  Connection_createmodule_DOC "createmodule($self,name,datasource)\n--\n\nConnection.createmodule(name: str, datasource: Any) -> None\n\n" \
"Registers a virtual table.  See :ref:`virtualtables` for details.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example-vtable>`\n" \
"\n" \
"Calls: `sqlite3_create_module_v2 <https://sqlite.org/c3ref/create_module.html>`__\n" 

#define Connection_createmodule_USAGE "Connection.createmodule(name: str, datasource: Any) -> None"

#define Connection_createmodule_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(datasource), PyObject *)); \
} while(0)


#define  Connection_createscalarfunction_DOC "createscalarfunction($self,name,callable,numargs=-1,deterministic=False)\n--\n\nConnection.createscalarfunction(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, deterministic: bool = False) -> None\n\n" \
"Registers a scalar function.  Scalar functions operate on one set of parameters once.\n" \
"\n" \
":param name: The string name of the function.  It should be less than 255 characters\n" \
":param callable: The function that will be called.  Use None to unregister.\n" \
":param numargs: How many arguments the function takes, with -1 meaning any number\n" \
":param deterministic: When True this means the function always\n" \
"         returns the same result for the same input arguments.\n" \
"         SQLite's query planner can perform additional optimisations\n" \
"         for deterministic functions.  For example a random()\n" \
"         function is not deterministic while one that returns the\n" \
"         length of a string is.\n" \
"\n" \
".. note::\n" \
"\n" \
"  You can register the same named function but with different\n" \
"  *callable* and *numargs*.  For example::\n" \
"\n" \
"    connection.createscalarfunction(\"toip\", ipv4convert, 4)\n" \
"    connection.createscalarfunction(\"toip\", ipv6convert, 16)\n" \
"    connection.createscalarfunction(\"toip\", strconvert, -1)\n" \
"\n" \
"  The one with the correct *numargs* will be called and only if that\n" \
"  doesn't exist then the one with negative *numargs* will be called.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <scalar-example>`\n" \
"   * :meth:`~Connection.createaggregatefunction`\n" \
"\n" \
"Calls: `sqlite3_create_function_v2 <https://sqlite.org/c3ref/create_function.html>`__\n" 

#define Connection_createscalarfunction_USAGE "Connection.createscalarfunction(name: str, callable: Optional[ScalarProtocol], numargs: int = -1, deterministic: bool = False) -> None"

#define Connection_createscalarfunction_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(numargs), int)); \
  assert(numargs == (-1)); \
  assert(__builtin_types_compatible_p(typeof(deterministic), int)); \
  assert(deterministic == 0); \
} while(0)


#define  Connection_cursor_DOC "cursor($self)\n--\n\nConnection.cursor() -> Cursor\n\n" \
"Creates a new :class:`Cursor` object on this database.\n" \
"\n" \
":rtype: :class:`Cursor`\n" 

#define  Connection_db_filename_DOC "db_filename($self,name)\n--\n\nConnection.db_filename(name: str) -> str\n\n" \
"Returns the full filename of the named (attached) database.  The\n" \
"main database is named \"main\".\n" \
"\n" \
"Calls: `sqlite3_db_filename <https://sqlite.org/c3ref/db_filename.html>`__\n" 

#define Connection_db_filename_USAGE "Connection.db_filename(name: str) -> str"

#define Connection_db_filename_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_db_names_DOC "db_names($self)\n--\n\nConnection.db_names() -> List[str]\n\n" \
"Returns the list of database names.  For example the first database\n" \
"is named 'main', the next 'temp', and the rest with the name provided\n" \
"in `ATTACH <https://www.sqlite.org/lang_attach.html>`__\n" \
"\n" \
"Calls: `sqlite3_db_name <https://sqlite.org/c3ref/db_name.html>`__\n" 

#define  Connection_deserialize_DOC "deserialize($self,name,contents)\n--\n\nConnection.deserialize(name: str, contents: bytes) -> None\n\n" \
"Replaces the named database with an in-memory copy of *contents*.\n" \
"*name* is **\"main\"** for the main database, **\"temp\"** for the\n" \
"temporary database etc.\n" \
"\n" \
"The resulting database is in-memory, read-write, and the memory is\n" \
"owned, resized, and freed by SQLite.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.serialize`\n" \
"\n" \
"Calls: `sqlite3_deserialize <https://sqlite.org/c3ref/deserialize.html>`__\n" 

#define Connection_deserialize_USAGE "Connection.deserialize(name: str, contents: bytes) -> None"

#define Connection_deserialize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(contents), Py_buffer)); \
} while(0)


#define  Connection_enableloadextension_DOC "enableloadextension($self,enable)\n--\n\nConnection.enableloadextension(enable: bool) -> None\n\n" \
"Enables/disables `extension loading\n" \
"<https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_\n" \
"which is disabled by default.\n" \
"\n" \
":param enable: If True then extension loading is enabled, else it is disabled.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.loadextension`\n" \
"\n" \
"Calls: `sqlite3_enable_load_extension <https://sqlite.org/c3ref/enable_load_extension.html>`__\n" 

#define Connection_enableloadextension_USAGE "Connection.enableloadextension(enable: bool) -> None"

#define Connection_enableloadextension_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(enable), int)); \
} while(0)


#define  Connection_enter_DOC "__enter__($self)\n--\n\nConnection.__enter__() -> Connection\n\n" \
"You can use the database as a `context manager\n" \
"<http://docs.python.org/reference/datamodel.html#with-statement-context-managers>`_\n" \
"as defined in :pep:`0343`.  When you use *with* a transaction is\n" \
"started.  If the block finishes with an exception then the\n" \
"transaction is rolled back, otherwise it is committed.  For example::\n" \
"\n" \
"  with connection:\n" \
"      connection.cursor().execute(\"....\")\n" \
"      with connection:\n" \
"          # nested is supported\n" \
"          call_function(connection)\n" \
"          connection.cursor().execute(\"...\")\n" \
"          with connection as db:\n" \
"              # You can also use 'as'\n" \
"              call_function2(db)\n" \
"              db.cursor().execute(\"...\")\n" \
"\n" \
"Behind the scenes the `savepoint\n" \
"<https://sqlite.org/lang_savepoint.html>`_ functionality introduced in\n" \
"SQLite 3.6.8 is used to provide nested transactions.\n" 

#define  Connection_exit_DOC "__exit__($self)\n--\n\nConnection.__exit__() -> Literal[False]\n\n" \
"Implements context manager in conjunction with\n" \
":meth:`~Connection.__enter__`.  Any exception that happened in the\n" \
"*with* block is raised after committing or rolling back the\n" \
"savepoint.\n" 

#define  Connection_filecontrol_DOC "filecontrol($self,dbname,op,pointer)\n--\n\nConnection.filecontrol(dbname: str, op: int, pointer: int) -> bool\n\n" \
"Calls the :meth:`~VFSFile.xFileControl` method on the :ref:`VFS`\n" \
"implementing :class:`file access <VFSFile>` for the database.\n" \
"\n" \
":param dbname: The name of the database to affect (eg \"main\", \"temp\", attached name)\n" \
":param op: A `numeric code\n" \
"  <https://sqlite.org/c3ref/c_fcntl_lockstate.html>`_ with values less\n" \
"  than 100 reserved for SQLite internal use.\n" \
":param pointer: A number which is treated as a ``void pointer`` at the C level.\n" \
"\n" \
":returns: True or False indicating if the VFS understood the op.\n" \
"\n" \
"If you want data returned back then the *pointer* needs to point to\n" \
"something mutable.  Here is an example using `ctypes\n" \
"<https://docs.python.org/3/library/ctypes.html>`_ of\n" \
"passing a Python dictionary to :meth:`~VFSFile.xFileControl` which\n" \
"can then modify the dictionary to set return values::\n" \
"\n" \
"  obj={\"foo\": 1, 2: 3}                 # object we want to pass\n" \
"  objwrap=ctypes.py_object(obj)        # objwrap must live before and after the call else\n" \
"                                       # it gets garbage collected\n" \
"  connection.filecontrol(\n" \
"           \"main\",                     # which db\n" \
"           123,                        # our op code\n" \
"           ctypes.addressof(objwrap))  # get pointer\n" \
"\n" \
"The :meth:`~VFSFile.xFileControl` method then looks like this::\n" \
"\n" \
"  def xFileControl(self, op, pointer):\n" \
"      if op==123:                      # our op code\n" \
"          obj=ctypes.py_object.from_address(pointer).value\n" \
"          # play with obj - you can use id() to verify it is the same\n" \
"          print(obj[\"foo\"])\n" \
"          obj[\"result\"]=\"it worked\"\n" \
"          return True\n" \
"      else:\n" \
"          # pass to parent/superclass\n" \
"          return super(MyFile, self).xFileControl(op, pointer)\n" \
"\n" \
"This is how you set the chunk size by which the database grows.  Do\n" \
"not combine it into one line as the c_int would be garbage collected\n" \
"before the filecontrol call is made::\n" \
"\n" \
"   chunksize=ctypes.c_int(32768)\n" \
"   connection.filecontrol(\"main\", apsw.SQLITE_FCNTL_CHUNK_SIZE, ctypes.addressof(chunksize))\n" \
"\n" \
"Calls: `sqlite3_file_control <https://sqlite.org/c3ref/file_control.html>`__\n" 

#define Connection_filecontrol_USAGE "Connection.filecontrol(dbname: str, op: int, pointer: int) -> bool"

#define Connection_filecontrol_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define  Connection_filename_DOC ":type: str\n" \
"\n" \
"The filename of the  database.\n" \
"\n" \
"Calls: `sqlite3_db_filename <https://sqlite.org/c3ref/db_filename.html>`__\n" 

#define  Connection_getautocommit_DOC "getautocommit($self)\n--\n\nConnection.getautocommit() -> bool\n\n" \
"Returns if the Connection is in auto commit mode (ie not in a transaction).\n" \
"\n" \
"Calls: `sqlite3_get_autocommit <https://sqlite.org/c3ref/get_autocommit.html>`__\n" 

#define  Connection_getexectrace_DOC "getexectrace($self)\n--\n\nConnection.getexectrace() -> Optional[ExecTracer]\n\n" \
"Returns the currently installed (via :meth:`~Connection.setexectrace`)\n" \
"execution tracer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define  Connection_getrowtrace_DOC "getrowtrace($self)\n--\n\nConnection.getrowtrace() -> Optional[RowTracer]\n\n" \
"Returns the currently installed (via :meth:`~Connection.setrowtrace`)\n" \
"row tracer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define  Connection_init_DOC "__init__($self,filename,flags=SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,vfs=None,statementcachesize=100)\n--\n\nConnection.__init__(filename: str, flags: int = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs: Optional[str] = None, statementcachesize: int = 100)\n\n" \
"This object wraps a `sqlite3 pointer\n" \
"<https://sqlite.org/c3ref/sqlite3.html>`_.\n" \
"\n" \
"Opens the named database.  You can use ``:memory:`` to get a private temporary\n" \
"in-memory database that is not shared with any other connections.\n" \
"\n" \
":param flags: One or more of the `open flags <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ orred together\n" \
":param vfs: The name of the `vfs <https://sqlite.org/c3ref/vfs.html>`_ to use.  If :const:`None` then the default\n" \
"   vfs will be used.\n" \
"\n" \
":param statementcachesize: Use zero to disable the statement cache,\n" \
"  or a number larger than the total distinct SQL statements you\n" \
"  execute frequently.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :attr:`apsw.connection_hooks`\n" \
"  * :ref:`statementcache`\n" \
"  * :ref:`vfs`\n" \
"\n" \
"Calls: `sqlite3_open_v2 <https://sqlite.org/c3ref/open.html>`__\n" 

#define Connection_init_USAGE "Connection.__init__(filename: str, flags: int = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, vfs: Optional[str] = None, statementcachesize: int = 100)"

#define Connection_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
  assert(flags == (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE)); \
  assert(__builtin_types_compatible_p(typeof(vfs), const char *)); \
  assert(vfs == 0); \
  assert(__builtin_types_compatible_p(typeof(statementcachesize), int)); \
  assert(statementcachesize == (100)); \
} while(0)


#define  Connection_interrupt_DOC "interrupt($self)\n--\n\nConnection.interrupt() -> None\n\n" \
"Causes any pending operations on the database to abort at the\n" \
"earliest opportunity. You can call this from any thread.  For\n" \
"example you may have a long running query when the user presses the\n" \
"stop button in your user interface.  :exc:`InterruptError`\n" \
"will be raised in the query that got interrupted.\n" \
"\n" \
"Calls: `sqlite3_interrupt <https://sqlite.org/c3ref/interrupt.html>`__\n" 

#define  Connection_last_insert_rowid_DOC "last_insert_rowid($self)\n--\n\nConnection.last_insert_rowid() -> int\n\n" \
"Returns the integer key of the most recent insert in the database.\n" \
"\n" \
"Calls: `sqlite3_last_insert_rowid <https://sqlite.org/c3ref/last_insert_rowid.html>`__\n" 

#define  Connection_limit_DOC "limit($self,id,newval=-1)\n--\n\nConnection.limit(id: int, newval: int = -1) -> int\n\n" \
"If called with one parameter then the current limit for that *id* is\n" \
"returned.  If called with two then the limit is set to *newval*.\n" \
"\n" \
":param id: One of the `runtime limit ids <https://sqlite.org/c3ref/c_limit_attached.html>`_\n" \
":param newval: The new limit.  This is a 32 bit signed integer even on 64 bit platforms.\n" \
"\n" \
":returns: The limit in place on entry to the call.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example-limit>`\n" \
"\n" \
"Calls: `sqlite3_limit <https://sqlite.org/c3ref/limit.html>`__\n" 

#define Connection_limit_USAGE "Connection.limit(id: int, newval: int = -1) -> int"

#define Connection_limit_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(id), int)); \
  assert(__builtin_types_compatible_p(typeof(newval), int)); \
  assert(newval == (-1)); \
} while(0)


#define  Connection_loadextension_DOC "loadextension($self,filename,entrypoint=None)\n--\n\nConnection.loadextension(filename: str, entrypoint: Optional[str] = None) -> None\n\n" \
"Loads *filename* as an `extension <https://sqlite.org/cvstrac/wiki/wiki?p=LoadableExtensions>`_\n" \
"\n" \
":param filename: The file to load.  This must be Unicode or Unicode compatible\n" \
"\n" \
":param entrypoint: The initialization method to call.  If this\n" \
"  parameter is not supplied then the SQLite default of\n" \
"  ``sqlite3_extension_init`` is used.\n" \
"\n" \
":raises ExtensionLoadingError: If the extension could not be\n" \
"  loaded.  The exception string includes more details.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`~Connection.enableloadextension`\n" \
"\n" \
"Calls: `sqlite3_load_extension <https://sqlite.org/c3ref/load_extension.html>`__\n" 

#define Connection_loadextension_USAGE "Connection.loadextension(filename: str, entrypoint: Optional[str] = None) -> None"

#define Connection_loadextension_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(entrypoint), const char *)); \
  assert(entrypoint == 0); \
} while(0)


#define  Connection_open_flags_DOC ":type: int\n" \
"\n" \
"The integer flags used to open the database.\n" 

#define  Connection_open_vfs_DOC ":type: str\n" \
"\n" \
"The string name of the vfs used to open the database.\n" 

#define  Connection_overloadfunction_DOC "overloadfunction($self,name,nargs)\n--\n\nConnection.overloadfunction(name: str, nargs: int) -> None\n\n" \
"Registers a placeholder function so that a virtual table can provide an implementation via\n" \
":meth:`VTTable.FindFunction`.\n" \
"\n" \
":param name: Function name\n" \
":param nargs: How many arguments the function takes\n" \
"\n" \
"Due to :cvstrac:`3507` underlying errors will not be returned.\n" \
"\n" \
"Calls: `sqlite3_overload_function <https://sqlite.org/c3ref/overload_function.html>`__\n" 

#define Connection_overloadfunction_USAGE "Connection.overloadfunction(name: str, nargs: int) -> None"

#define Connection_overloadfunction_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(nargs), int)); \
} while(0)


#define  Connection_readonly_DOC "readonly($self,name)\n--\n\nConnection.readonly(name: str) -> bool\n\n" \
"True or False if the named (attached) database was opened readonly or file\n" \
"permissions don't allow writing.  The main database is named \"main\".\n" \
"\n" \
"An exception is raised if the database doesn't exist.\n" \
"\n" \
"Calls: `sqlite3_db_readonly <https://sqlite.org/c3ref/db_readonly.html>`__\n" 

#define Connection_readonly_USAGE "Connection.readonly(name: str) -> bool"

#define Connection_readonly_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_serialize_DOC "serialize($self,name)\n--\n\nConnection.serialize(name: str) -> bytes\n\n" \
"Returns a memory copy of the database. *name* is **\"main\"** for the\n" \
"main database, **\"temp\"** for the temporary database etc.\n" \
"\n" \
"The memory copy is the same as if the database was backed up to\n" \
"disk.\n" \
"\n" \
"If the database name doesn't exist or is empty, then None is\n" \
"returned, not an exception (this is SQLite's behaviour).\n" \
"\n" \
" .. seealso::\n" \
"\n" \
"   * :meth:`Connection.deserialize`\n" \
"\n" \
"Calls: `sqlite3_serialize <https://sqlite.org/c3ref/serialize.html>`__\n" 

#define Connection_serialize_USAGE "Connection.serialize(name: str) -> bytes"

#define Connection_serialize_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  Connection_set_last_insert_rowid_DOC "set_last_insert_rowid($self,rowid)\n--\n\nConnection.set_last_insert_rowid(rowid: int) -> None\n\n" \
"Sets the value calls to :meth:`last_insert_rowid` will return.\n" \
"\n" \
"Calls: `sqlite3_set_last_insert_rowid <https://sqlite.org/c3ref/set_last_insert_rowid.html>`__\n" 

#define Connection_set_last_insert_rowid_USAGE "Connection.set_last_insert_rowid(rowid: int) -> None"

#define Connection_set_last_insert_rowid_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(rowid), long long)); \
} while(0)


#define  Connection_setauthorizer_DOC "setauthorizer($self,callable)\n--\n\nConnection.setauthorizer(callable: Optional[Callable[[int, Optional[str], Optional[str], Optional[str], Optional[str]], int]]) -> None\n\n" \
"While `preparing <https://sqlite.org/c3ref/prepare.html>`_\n" \
"statements, SQLite will call any defined authorizer to see if a\n" \
"particular action is ok to be part of the statement.\n" \
"\n" \
"Typical usage would be if you are running user supplied SQL and want\n" \
"to prevent harmful operations.  You should also\n" \
"set the :class:`statementcachesize <Connection>` to zero.\n" \
"\n" \
"The authorizer callback has 5 parameters:\n" \
"\n" \
"  * An `operation code <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string (or None) dependent on the operation `(listed as 3rd) <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string (or None) dependent on the operation `(listed as 4th) <https://sqlite.org/c3ref/c_alter_table.html>`_\n" \
"  * A string name of the database (or None)\n" \
"  * Name of the innermost trigger or view doing the access (or None)\n" \
"\n" \
"The authorizer callback should return one of :const:`SQLITE_OK`,\n" \
":const:`SQLITE_DENY` or :const:`SQLITE_IGNORE`.\n" \
"(:const:`SQLITE_DENY` is returned if there is an error in your\n" \
"Python code).\n" \
"\n" \
"Passing None unregisters the existing authorizer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <authorizer-example>`\n" \
"  * :ref:`statementcache`\n" \
"\n" \
"Calls: `sqlite3_set_authorizer <https://sqlite.org/c3ref/set_authorizer.html>`__\n" 

#define Connection_setauthorizer_USAGE "Connection.setauthorizer(callable: Optional[Callable[[int, Optional[str], Optional[str], Optional[str], Optional[str]], int]]) -> None"

#define Connection_setauthorizer_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setbusyhandler_DOC "setbusyhandler($self,callable)\n--\n\nConnection.setbusyhandler(callable: Optional[Callable[[int], bool]]) -> None\n\n" \
"Sets the busy handler to callable. callable will be called with one\n" \
"integer argument which is the number of prior calls to the busy\n" \
"callback for the same lock. If the busy callback returns False,\n" \
"then SQLite returns :const:`SQLITE_BUSY` to the calling code. If\n" \
"the callback returns True, then SQLite tries to open the table\n" \
"again and the cycle repeats.\n" \
"\n" \
"If you previously called :meth:`~Connection.setbusytimeout` then\n" \
"calling this overrides that.\n" \
"\n" \
"Passing None unregisters the existing handler.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :meth:`Connection.setbusytimeout`\n" \
"  * :ref:`Busy handling <busyhandling>`\n" \
"\n" \
"Calls: `sqlite3_busy_handler <https://sqlite.org/c3ref/busy_handler.html>`__\n" 

#define Connection_setbusyhandler_USAGE "Connection.setbusyhandler(callable: Optional[Callable[[int], bool]]) -> None"

#define Connection_setbusyhandler_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setbusytimeout_DOC "setbusytimeout($self,milliseconds)\n--\n\nConnection.setbusytimeout(milliseconds: int) -> None\n\n" \
"If the database is locked such as when another connection is making\n" \
"changes, SQLite will keep retrying.  This sets the maximum amount of\n" \
"time SQLite will keep retrying before giving up.  If the database is\n" \
"still busy then :class:`apsw.BusyError` will be returned.\n" \
"\n" \
":param milliseconds: Maximum thousandths of a second to wait.\n" \
"\n" \
"If you previously called :meth:`~Connection.setbusyhandler` then\n" \
"calling this overrides that.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :meth:`Connection.setbusyhandler`\n" \
"   * :ref:`Busy handling <busyhandling>`\n" \
"\n" \
"Calls: `sqlite3_busy_timeout <https://sqlite.org/c3ref/busy_timeout.html>`__\n" 

#define Connection_setbusytimeout_USAGE "Connection.setbusytimeout(milliseconds: int) -> None"

#define Connection_setbusytimeout_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(milliseconds), int)); \
} while(0)


#define  Connection_setcommithook_DOC "setcommithook($self,callable)\n--\n\nConnection.setcommithook(callable: Optional[Callable[[], None]]) -> None\n\n" \
"*callable* will be called just before a commit.  It should return\n" \
"False for the commit to go ahead and True for it to be turned\n" \
"into a rollback. In the case of an exception in your callable, a\n" \
"True (ie rollback) value is returned.  Pass None to unregister\n" \
"the existing hook.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`Example <example-commithook>`\n" \
"\n" \
"Calls: `sqlite3_commit_hook <https://sqlite.org/c3ref/commit_hook.html>`__\n" 

#define Connection_setcommithook_USAGE "Connection.setcommithook(callable: Optional[Callable[[], None]]) -> None"

#define Connection_setcommithook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setexectrace_DOC "setexectrace($self,callable)\n--\n\nConnection.setexectrace(callable: Optional[ExecTracer]) -> None\n\n" \
"*callable* is called with the cursor, statement and bindings for\n" \
"each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this\n" \
"Connection, unless the :class:`Cursor` installed its own\n" \
"tracer. Your execution tracer can also abort execution of a\n" \
"statement.\n" \
"\n" \
"If *callable* is :const:`None` then any existing execution tracer is\n" \
"removed.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :meth:`Cursor.setexectrace`\n" 

#define Connection_setexectrace_USAGE "Connection.setexectrace(callable: Optional[ExecTracer]) -> None"

#define Connection_setexectrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setprofile_DOC "setprofile($self,callable)\n--\n\nConnection.setprofile(callable: Optional[Callable[[str, int], None]]) -> None\n\n" \
"Sets a callable which is invoked at the end of execution of each\n" \
"statement and passed the statement string and how long it took to\n" \
"execute. (The execution time is in nanoseconds.) Note that it is\n" \
"called only on completion. If for example you do a ``SELECT`` and\n" \
"only read the first result, then you won't reach the end of the\n" \
"statement.\n" \
"\n" \
"Calls: `sqlite3_profile <https://sqlite.org/c3ref/profile.html>`__\n" 

#define Connection_setprofile_USAGE "Connection.setprofile(callable: Optional[Callable[[str, int], None]]) -> None"

#define Connection_setprofile_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setprogresshandler_DOC "setprogresshandler($self,callable,nsteps=20)\n--\n\nConnection.setprogresshandler(callable: Optional[Callable[[], bool]], nsteps: int = 20) -> None\n\n" \
"Sets a callable which is invoked every *nsteps* SQLite\n" \
"inststructions. The callable should return True to abort\n" \
"or False to continue. (If there is an error in your Python *callable*\n" \
"then True/abort will be returned).\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`Example <example-progress-handler>`\n" \
"\n" \
"Calls: `sqlite3_progress_handler <https://sqlite.org/c3ref/progress_handler.html>`__\n" 

#define Connection_setprogresshandler_USAGE "Connection.setprogresshandler(callable: Optional[Callable[[], bool]], nsteps: int = 20) -> None"

#define Connection_setprogresshandler_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(nsteps), int)); \
  assert(nsteps == (20)); \
} while(0)


#define  Connection_setrollbackhook_DOC "setrollbackhook($self,callable)\n--\n\nConnection.setrollbackhook(callable: Optional[Callable[[], None]]) -> None\n\n" \
"Sets a callable which is invoked during a rollback.  If *callable*\n" \
"is :const:`None` then any existing rollback hook is unregistered.\n" \
"\n" \
"The *callable* is called with no parameters and the return value is ignored.\n" \
"\n" \
"Calls: `sqlite3_rollback_hook <https://sqlite.org/c3ref/commit_hook.html>`__\n" 

#define Connection_setrollbackhook_USAGE "Connection.setrollbackhook(callable: Optional[Callable[[], None]]) -> None"

#define Connection_setrollbackhook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setrowtrace_DOC "setrowtrace($self,callable)\n--\n\nConnection.setrowtrace(callable: Optional[RowTracer]) -> None\n\n" \
"*callable* is called with the cursor and row being returned for\n" \
":class:`cursors <Cursor>` associated with this Connection, unless\n" \
"the Cursor installed its own tracer.  You can change the data that\n" \
"is returned or cause the row to be skipped altogether.\n" \
"\n" \
"If *callable* is :const:`None` then any existing row tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :meth:`Cursor.setexectrace`\n" 

#define Connection_setrowtrace_USAGE "Connection.setrowtrace(callable: Optional[RowTracer]) -> None"

#define Connection_setrowtrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setupdatehook_DOC "setupdatehook($self,callable)\n--\n\nConnection.setupdatehook(callable: Optional[Callable[[int, str, str, int], None]]) -> None\n\n" \
"Calls *callable* whenever a row is updated, deleted or inserted.  If\n" \
"*callable* is :const:`None` then any existing update hook is\n" \
"unregistered.  The update hook cannot make changes to the database while\n" \
"the query is still executing, but can record them for later use or\n" \
"apply them in a different connection.\n" \
"\n" \
"The update hook is called with 4 parameters:\n" \
"\n" \
"  type (int)\n" \
"    :const:`SQLITE_INSERT`, :const:`SQLITE_DELETE` or :const:`SQLITE_UPDATE`\n" \
"  database name (string)\n" \
"    This is ``main`` for the database or the name specified in\n" \
"    `ATTACH <https://sqlite.org/lang_attach.html>`_\n" \
"  table name (string)\n" \
"    The table on which the update happened\n" \
"  rowid (64 bit integer)\n" \
"    The affected row\n" \
"\n" \
".. seealso::\n" \
"\n" \
"    * :ref:`Example <example-updatehook>`\n" \
"\n" \
"Calls: `sqlite3_update_hook <https://sqlite.org/c3ref/update_hook.html>`__\n" 

#define Connection_setupdatehook_USAGE "Connection.setupdatehook(callable: Optional[Callable[[int, str, str, int], None]]) -> None"

#define Connection_setupdatehook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_setwalhook_DOC "setwalhook($self,callable)\n--\n\nConnection.setwalhook(callable: Optional[Callable[[Connection, str, int], int]]) -> None\n\n" \
"*callable* will be called just after data is committed in :ref:`wal`\n" \
"mode.  It should return :const:`SQLITE_OK` or an error code.  The\n" \
"callback is called with 3 parameters:\n" \
"\n" \
"  * The Connection\n" \
"  * The database name (eg \"main\" or the name of an attached database)\n" \
"  * The number of pages in the wal log\n" \
"\n" \
"You can pass in None in order to unregister an existing hook.\n" \
"\n" \
"Calls: `sqlite3_wal_hook <https://sqlite.org/c3ref/wal_hook.html>`__\n" 

#define Connection_setwalhook_USAGE "Connection.setwalhook(callable: Optional[Callable[[Connection, str, int], int]]) -> None"

#define Connection_setwalhook_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Connection_sqlite3pointer_DOC "sqlite3pointer($self)\n--\n\nConnection.sqlite3pointer() -> int\n\n" \
"Returns the underlying `sqlite3 *\n" \
"<https://sqlite.org/c3ref/sqlite3.html>`_ for the connection. This\n" \
"method is useful if there are other C level libraries in the same\n" \
"process and you want them to use the APSW connection handle. The\n" \
"value is returned as a number using :meth:`PyLong_FromVoidPtr` under the\n" \
"hood. You should also ensure that you increment the reference count on\n" \
"the :class:`Connection` for as long as the other libraries are using\n" \
"the pointer.  It is also a very good idea to call\n" \
":meth:`sqlitelibversion` and ensure it is the same as the other\n" \
"libraries.\n" 

#define  Connection_status_DOC "status($self,op,reset=False)\n--\n\nConnection.status(op: int, reset: bool = False) -> Tuple[int, int]\n\n" \
"Returns current and highwater measurements for the database.\n" \
"\n" \
":param op: A `status parameter <https://sqlite.org/c3ref/c_dbstatus_options.html>`_\n" \
":param reset: If *True* then the highwater is set to the current value\n" \
":returns: A tuple of current value and highwater value\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  The :func:`status` example which works in exactly the same way.\n" \
"\n" \
"  * :ref:`Status example <example-status>`\n" \
"\n" \
"Calls: `sqlite3_db_status <https://sqlite.org/c3ref/db_status.html>`__\n" 

#define Connection_status_USAGE "Connection.status(op: int, reset: bool = False) -> Tuple[int, int]"

#define Connection_status_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(reset), int)); \
  assert(reset == 0); \
} while(0)


#define  Connection_totalchanges_DOC "totalchanges($self)\n--\n\nConnection.totalchanges() -> int\n\n" \
"Returns the total number of database rows that have be modified,\n" \
"inserted, or deleted since the database connection was opened.\n" \
"\n" \
"Calls: `sqlite3_total_changes64 <https://sqlite.org/c3ref/total_changes.html>`__\n" 

#define  Connection_txn_state_DOC "txn_state($self,schema=None)\n--\n\nConnection.txn_state(schema: Optional[str] = None) -> int\n\n" \
"Returns the current transaction state of the database, or a specific schema\n" \
"if provided.  ValueError is raised if schema is not None or a valid schema name.\n" \
":attr:`apsw.mapping_txn_state` contains the names and values returned.\n" \
"\n" \
"Calls: `sqlite3_txn_state <https://sqlite.org/c3ref/txn_state.html>`__\n" 

#define Connection_txn_state_USAGE "Connection.txn_state(schema: Optional[str] = None) -> int"

#define Connection_txn_state_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(schema), const char *)); \
  assert(schema == 0); \
} while(0)


#define  Connection_wal_autocheckpoint_DOC "wal_autocheckpoint($self,n)\n--\n\nConnection.wal_autocheckpoint(n: int) -> None\n\n" \
"Sets how often the :ref:`wal` checkpointing is run.\n" \
"\n" \
":param n: A number representing the checkpointing interval or\n" \
"  zero/negative to disable auto checkpointing.\n" \
"\n" \
"Calls: `sqlite3_wal_autocheckpoint <https://sqlite.org/c3ref/wal_autocheckpoint.html>`__\n" 

#define Connection_wal_autocheckpoint_USAGE "Connection.wal_autocheckpoint(n: int) -> None"

#define Connection_wal_autocheckpoint_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(n), int)); \
} while(0)


#define  Connection_wal_checkpoint_DOC "wal_checkpoint($self,dbname=None,mode=apsw.SQLITE_CHECKPOINT_PASSIVE)\n--\n\nConnection.wal_checkpoint(dbname: Optional[str] = None, mode: int = apsw.SQLITE_CHECKPOINT_PASSIVE) -> Tuple[int, int]\n\n" \
"Does a WAL checkpoint.  Has no effect if the database(s) are not in WAL mode.\n" \
"\n" \
":param dbname:  The name of the database or all databases if None\n" \
"\n" \
":param mode: One of the `checkpoint modes <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.\n" \
"\n" \
":return: A tuple of the size of the WAL log in frames and the\n" \
"   number of frames checkpointed as described in the\n" \
"   `documentation\n" \
"   <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__.\n" \
"\n" \
"Calls: `sqlite3_wal_checkpoint_v2 <https://sqlite.org/c3ref/wal_checkpoint_v2.html>`__\n" 

#define Connection_wal_checkpoint_USAGE "Connection.wal_checkpoint(dbname: Optional[str] = None, mode: int = apsw.SQLITE_CHECKPOINT_PASSIVE) -> Tuple[int, int]"

#define Connection_wal_checkpoint_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(dbname), const char *)); \
  assert(dbname == 0); \
  assert(__builtin_types_compatible_p(typeof(mode), int)); \
  assert(mode == (SQLITE_CHECKPOINT_PASSIVE)); \
} while(0)


#define  Cursor_close_DOC "close($self,force=False)\n--\n\nCursor.close(force: bool = False) -> None\n\n" \
"It is very unlikely you will need to call this method.  It exists\n" \
"because older versions of SQLite required all Connection/Cursor\n" \
"activity to be confined to the same thread.  That is no longer the\n" \
"case.  Cursors are automatically garbage collected and when there\n" \
"are none left will allow the connection to be garbage collected if\n" \
"it has no other references.\n" \
"\n" \
"A cursor is open if there are remaining statements to execute (if\n" \
"your query included multiple statements), or if you called\n" \
":meth:`~Cursor.executemany` and not all of the *sequenceofbindings*\n" \
"have been used yet.\n" \
"\n" \
":param force: If False then you will get exceptions if there is\n" \
" remaining work to do be in the Cursor such as more statements to\n" \
" execute, more data from the executemany binding sequence etc. If\n" \
" force is True then all remaining work and state information will be\n" \
" silently discarded.\n" 

#define Cursor_close_USAGE "Cursor.close(force: bool = False) -> None"

#define Cursor_close_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(force), int)); \
  assert(force == 0); \
} while(0)


#define  Cursor_description_DOC ":type: Tuple[Tuple[str, str, None, None, None, None, None], ...]\n" \
"\n" \
"Based on the `DB-API cursor property\n" \
"<http://www.python.org/dev/peps/pep-0249/>`__, this returns the\n" \
"same as :meth:`getdescription` but with 5 Nones appended.  See\n" \
"also :issue:`131`.\n" 

#define  Cursor_execute_DOC "execute($self,statements,bindings=None)\n--\n\nCursor.execute(statements: str, bindings: Optional[Bindings] = None) -> Cursor\n\n" \
"Executes the statements using the supplied bindings.  Execution\n" \
"returns when the first row is available or all statements have\n" \
"completed.\n" \
"\n" \
":param statements: One or more SQL statements such as ``select *\n" \
"  from books`` or ``begin; insert into books ...; select\n" \
"  last_insert_rowid(); end``.\n" \
":param bindings: If supplied should either be a sequence or a dictionary.  Each item must be one of the :ref:`supported types <types>`\n" \
"\n" \
"If you use numbered bindings in the query then supply a sequence.\n" \
"Any sequence will work including lists and iterators.  For\n" \
"example::\n" \
"\n" \
"  cursor.execute(\"insert into books values(?,?)\", (\"title\", \"number\"))\n" \
"\n" \
".. note::\n" \
"\n" \
"  A common gotcha is wanting to insert a single string but not\n" \
"  putting it in a tuple::\n" \
"\n" \
"    cursor.execute(\"insert into books values(?)\", \"a title\")\n" \
"\n" \
"  The string is a sequence of 8 characters and so it will look\n" \
"  like you are supplying 8 bindings when only one is needed.  Use\n" \
"  a one item tuple with a trailing comma like this::\n" \
"\n" \
"    cursor.execute(\"insert into books values(?)\", (\"a title\",) )\n" \
"\n" \
"If you used names in the statement then supply a dictionary as the\n" \
"binding.  It is ok to be missing entries from the dictionary -\n" \
"None/null will be used.  For example::\n" \
"\n" \
"   cursor.execute(\"insert into books values(:title, :isbn, :rating)\",\n" \
"        {\"title\": \"book title\", \"isbn\": 908908908})\n" \
"\n" \
"The return is the cursor object itself which is also an iterator.  This allows you to write::\n" \
"\n" \
"   for row in cursor.execute(\"select * from books\"):\n" \
"      print(row)\n" \
"\n" \
":raises TypeError: The bindings supplied were neither a dict nor a sequence\n" \
":raises BindingsError: You supplied too many or too few bindings for the statements\n" \
":raises IncompleteExecutionError: There are remaining unexecuted queries from your last execute\n" \
"\n" \
".. seealso::\n" \
"\n" \
"   * :ref:`executionmodel`\n" \
"   * :ref:`Example <example-cursor>`\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_prepare_v2 <https://sqlite.org/c3ref/prepare.html>`__\n" \
"  * `sqlite3_step <https://sqlite.org/c3ref/step.html>`__\n" \
"  * `sqlite3_bind_int64 <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_null <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_text <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_double <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_blob <https://sqlite.org/c3ref/bind_blob.html>`__\n" \
"  * `sqlite3_bind_zeroblob <https://sqlite.org/c3ref/bind_blob.html>`__\n" 

#define Cursor_execute_USAGE "Cursor.execute(statements: str, bindings: Optional[Bindings] = None) -> Cursor"

#define Cursor_execute_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statements), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(bindings), PyObject *)); \
  assert(bindings == NULL); \
} while(0)


#define  Cursor_executemany_DOC "executemany($self,statements,sequenceofbindings)\n--\n\nCursor.executemany(statements: str, sequenceofbindings: Sequence[Bindings]) -> Cursor\n\n" \
"This method is for when you want to execute the same statements over\n" \
"a sequence of bindings.  Conceptually it does this::\n" \
"\n" \
"  for binding in sequenceofbindings:\n" \
"      cursor.execute(statements, binding)\n" \
"\n" \
"Example::\n" \
"\n" \
"  rows=(  (1, 7),\n" \
"          (2, 23),\n" \
"          (4, 92),\n" \
"          (12, 12) )\n" \
"\n" \
"  cursor.executemany(\"insert into nums values(?,?)\", rows)\n" \
"\n" \
"The return is the cursor itself which acts as an iterator.  Your\n" \
"statements can return data.  See :meth:`~Cursor.execute` for more\n" \
"information.\n" 

#define Cursor_executemany_USAGE "Cursor.executemany(statements: str, sequenceofbindings: Sequence[Bindings]) -> Cursor"

#define Cursor_executemany_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(statements), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(sequenceofbindings), PyObject *)); \
} while(0)


#define  Cursor_fetchall_DOC "fetchall($self)\n--\n\nCursor.fetchall() -> list[Tuple[SQLiteValue, ...]]\n\n" \
"Returns all remaining result rows as a list.  This method is defined\n" \
"in DBAPI.  It is a longer way of doing ``list(cursor)``.\n" 

#define  Cursor_fetchone_DOC "fetchone($self)\n--\n\nCursor.fetchone() -> Optional[Any]\n\n" \
"Returns the next row of data or None if there are no more rows.\n" 

#define  Cursor_getconnection_DOC "getconnection($self)\n--\n\nCursor.getconnection() -> Connection\n\n" \
"Returns the :class:`Connection` this cursor belongs to.  An example usage is to get another cursor::\n" \
"\n" \
"  def func(cursor):\n" \
"    # I don't want to alter existing cursor, so make a new one\n" \
"    mycursor=cursor.getconnection().cursor()\n" \
"    mycursor.execute(\"....\")\n" 

#define  Cursor_getdescription_DOC "getdescription($self)\n--\n\nCursor.getdescription() -> Tuple[Tuple[str, str], ...]\n\n" \
"If you are trying to get information about a table or view,\n" \
"then `pragma table_info <https://sqlite.org/pragma.html#pragma_table_info>`__\n" \
"is better.\n" \
"\n" \
"Returns a tuple describing each column in the result row.  The\n" \
"return is identical for every row of the results.  You can only\n" \
"call this method once you have started executing a statement and\n" \
"before you have finished::\n" \
"\n" \
"   # This will error\n" \
"   cursor.getdescription()\n" \
"\n" \
"   for row in cursor.execute(\"select .....\"):\n" \
"      # this works\n" \
"      print (cursor.getdescription())\n" \
"      print (row)\n" \
"\n" \
"The information about each column is a tuple of ``(column_name,\n" \
"declared_column_type)``.  The type is what was declared in the\n" \
"``CREATE TABLE`` statement - the value returned in the row will be\n" \
"whatever type you put in for that row and column.  (This is known\n" \
"as `manifest typing <https://sqlite.org/different.html#typing>`_\n" \
"which is also the way that Python works.  The variable ``a`` could\n" \
"contain an integer, and then you could put a string in it.  Other\n" \
"static languages such as C or other SQL databases only let you put\n" \
"one type in - eg ``a`` could only contain an integer or a string,\n" \
"but never both.)\n" \
"\n" \
"Example::\n" \
"\n" \
"   cursor.execute(\"create table books(title string, isbn number, wibbly wobbly zebra)\")\n" \
"   cursor.execute(\"insert into books values(?,?,?)\", (97, \"fjfjfj\", 3.7))\n" \
"   cursor.execute(\"insert into books values(?,?,?)\", (\"fjfjfj\", 3.7, 97))\n" \
"\n" \
"   for row in cursor.execute(\"select * from books\"):\n" \
"      print (cursor.getdescription())\n" \
"      print (row)\n" \
"\n" \
"Output::\n" \
"\n" \
"  # row 0 - description\n" \
"  (('title', 'string'), ('isbn', 'number'), ('wibbly', 'wobbly zebra'))\n" \
"  # row 0 - values\n" \
"  (97, 'fjfjfj', 3.7)\n" \
"  # row 1 - description\n" \
"  (('title', 'string'), ('isbn', 'number'), ('wibbly', 'wobbly zebra'))\n" \
"  # row 1 - values\n" \
"  ('fjfjfj', 3.7, 97)\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_column_name <https://sqlite.org/c3ref/column_name.html>`__\n" \
"  * `sqlite3_column_decltype <https://sqlite.org/c3ref/column_decltype.html>`__\n" 

#define  Cursor_getexectrace_DOC "getexectrace($self)\n--\n\nCursor.getexectrace() -> Optional[ExecTracer]\n\n" \
"Returns the currently installed (via :meth:`~Cursor.setexectrace`)\n" \
"execution tracer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define  Cursor_getrowtrace_DOC "getrowtrace($self)\n--\n\nCursor.getrowtrace() -> Optional[RowTracer]\n\n" \
"Returns the currently installed (via :meth:`~Cursor.setrowtrace`)\n" \
"row tracer.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" 

#define  Cursor_init_DOC "__init__($self)\n--\n\nCursor.__init__() -> None\n\n" \
"You obtain cursors by calling :meth:`Connection.cursor`.\n" 

#define  Cursor_iter_DOC "__iter__($self,self)\n--\n\nCursor.__iter__(self: Cursor) -> Cursor\n\n" \
"Cursors are iterators\n" 

#define  Cursor_next_DOC "__next__($self,self)\n--\n\nCursor.__next__(self: Cursor) -> Any\n\n" \
"Cursors are iterators\n" 

#define  Cursor_setexectrace_DOC "setexectrace($self,callable)\n--\n\nCursor.setexectrace(callable: Optional[ExecTracer]) -> None\n\n" \
"*callable* is called with the cursor, statement and bindings for\n" \
"each :meth:`~Cursor.execute` or :meth:`~Cursor.executemany` on this\n" \
"cursor.\n" \
"\n" \
"If *callable* is :const:`None` then any existing execution tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`executiontracer`\n" \
"  * :meth:`Connection.setexectrace`\n" 

#define Cursor_setexectrace_USAGE "Cursor.setexectrace(callable: Optional[ExecTracer]) -> None"

#define Cursor_setexectrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  Cursor_setrowtrace_DOC "setrowtrace($self,callable)\n--\n\nCursor.setrowtrace(callable: Optional[RowTracer]) -> None\n\n" \
"*callable* is called with cursor and row being returned.  You can\n" \
"change the data that is returned or cause the row to be skipped\n" \
"altogether.\n" \
"\n" \
"If *callable* is :const:`None` then any existing row tracer is\n" \
"unregistered.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  * :ref:`tracing`\n" \
"  * :ref:`rowtracer`\n" \
"  * :meth:`Connection.setexectrace`\n" 

#define Cursor_setrowtrace_USAGE "Cursor.setrowtrace(callable: Optional[RowTracer]) -> None"

#define Cursor_setrowtrace_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(callable), PyObject *)); \
} while(0)


#define  URIFilename_filename_DOC "filename($self)\n--\n\nURIFilename.filename() -> str\n\n" \
"Returns the filename.\n" 

#define  URIFilename_init_DOC "__init__($self)\n--\n\nURIFilename.__init__() -> None\n\n" \
"SQLite uses a convoluted method of storing `uri parameters\n" \
"<https://sqlite.org/uri.html>`__ after the filename binding the\n" \
"C filename representation and parameters together.  This class\n" \
"encapsulates that binding.  The :ref:`example <example-vfs>` shows\n" \
"usage of this class.\n" \
"\n" \
"Your :meth:`VFS.xOpen` method will generally be passed one of\n" \
"these instead of a string as the filename if the URI flag was used\n" \
"or the main database flag is set.\n" \
"\n" \
"You can safely pass it on to the :class:`VFSFile` constructor\n" \
"which knows how to get the name back out.\n" 

#define  URIFilename_uri_boolean_DOC "uri_boolean($self,name,default)\n--\n\nURIFilename.uri_boolean(name: str, default: bool) -> bool\n\n" \
"Returns the boolean value for parameter `name` or `default` if not\n" \
"present.\n" \
"\n" \
"Calls: `sqlite3_uri_boolean <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_boolean_USAGE "URIFilename.uri_boolean(name: str, default: bool) -> bool"

#define URIFilename_uri_boolean_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(default_), int)); \
} while(0)


#define  URIFilename_uri_int_DOC "uri_int($self,name,default)\n--\n\nURIFilename.uri_int(name: str, default: int) -> int\n\n" \
"Returns the integer value for parameter `name` or `default` if not\n" \
"present.\n" \
"\n" \
"Calls: `sqlite3_uri_int64 <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_int_USAGE "URIFilename.uri_int(name: str, default: int) -> int"

#define URIFilename_uri_int_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(default_), long long)); \
} while(0)


#define  URIFilename_uri_parameter_DOC "uri_parameter($self,name)\n--\n\nURIFilename.uri_parameter(name: str) -> Optional[str]\n\n" \
"Returns the value of parameter `name` or None.\n" \
"\n" \
"Calls: `sqlite3_uri_parameter <https://sqlite.org/c3ref/uri_boolean.html>`__\n" 

#define URIFilename_uri_parameter_USAGE "URIFilename.uri_parameter(name: str) -> Optional[str]"

#define URIFilename_uri_parameter_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFSFile_excepthook_DOC "excepthook($self,etype,evalue,etraceback)\n--\n\nVFSFile.excepthook(etype: type[BaseException], evalue: BaseException, etraceback: Optional[TracebackType]) ->None\n\n" \
"Called when there has been an exception in a :class:`VFSFile`\n" \
"routine.  The default implementation calls ``sys.excepthook`` and\n" \
"if that fails then ``PyErr_Display``.  The three arguments\n" \
"correspond to what ``sys.exc_info()`` would return.\n" \
"\n" \
":param etype: The exception type\n" \
":param evalue: The exception  value\n" \
":param etraceback: The exception traceback.  Note this\n" \
"  includes all frames all the way up to the thread being started.\n" 

#define  VFSFile_init_DOC "__init__($self,vfs,filename,flags)\n--\n\nVFSFile.__init__(vfs: str, filename: Union[str,URIFilename], flags: List[int])\n\n" \
"Wraps access to a file.  You only need to derive from this class\n" \
"if you want the file object returned from :meth:`VFS.xOpen` to\n" \
"inherit from an existing VFS implementation.\n" \
"\n" \
".. note::\n" \
"\n" \
"   All file sizes and offsets are 64 bit quantities even on 32 bit\n" \
"   operating systems.\n" \
"\n" \
":param vfs: The vfs you want to inherit behaviour from.  You can\n" \
"   use an empty string ``\"\"`` to inherit from the default vfs.\n" \
":param name: The name of the file being opened.  May be an instance of :class:`URIFilename`.\n" \
":param flags: A two item list ``[inflags, outflags]`` as detailed in :meth:`VFS.xOpen`.\n" \
"\n" \
":raises ValueError: If the named VFS is not registered.\n" \
"\n" \
".. note::\n" \
"\n" \
"  If the VFS that you inherit from supports :ref:`write ahead\n" \
"  logging <wal>` then your :class:`VFSFile` will also support the\n" \
"  xShm methods necessary to implement wal.\n" \
"\n" \
".. seealso::\n" \
"\n" \
"  :meth:`VFS.xOpen`\n" 

#define VFSFile_init_USAGE "VFSFile.__init__(vfs: str, filename: Union[str,URIFilename], flags: List[int])"

#define VFSFile_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(vfs), const char *)); \
  assert(__builtin_types_compatible_p(typeof(filename), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), PyObject *)); \
} while(0)


#define  VFSFile_xCheckReservedLock_DOC "xCheckReservedLock($self)\n--\n\nVFSFile.xCheckReservedLock() -> bool\n\n" \
"Returns True if any database connection (in this or another process)\n" \
"has a lock other than `SQLITE_LOCK_NONE or SQLITE_LOCK_SHARED\n" \
"<https://sqlite.org/c3ref/c_lock_exclusive.html>`_.\n" 

#define  VFSFile_xClose_DOC "xClose($self)\n--\n\nVFSFile.xClose() -> None\n\n" \
"Close the database. Note that even if you return an error you should\n" \
"still close the file.  It is safe to call this method multiple\n" \
"times.\n" 

#define  VFSFile_xDeviceCharacteristics_DOC "xDeviceCharacteristics($self)\n--\n\nVFSFile.xDeviceCharacteristics() -> int\n\n" \
"Return `I/O capabilities\n" \
"<https://sqlite.org/c3ref/c_iocap_atomic.html>`_ (bitwise or of\n" \
"appropriate values). If you do not implement the function or have an\n" \
"error then 0 (the SQLite default) is returned.\n" 

#define  VFSFile_xFileControl_DOC "xFileControl($self,op,ptr)\n--\n\nVFSFile.xFileControl(op: int, ptr: int) -> bool\n\n" \
"Receives `file control\n" \
"<https://sqlite.org/c3ref/file_control.html>`_ request typically\n" \
"issued by :meth:`Connection.filecontrol`.  See\n" \
":meth:`Connection.filecontrol` for an example of how to pass a\n" \
"Python object to this routine.\n" \
"\n" \
":param op: A numeric code.  Codes below 100 are reserved for SQLite\n" \
"  internal use.\n" \
":param ptr: An integer corresponding to a pointer at the C level.\n" \
"\n" \
":returns: A boolean indicating if the op was understood\n" \
"\n" \
"As of SQLite 3.6.10, this method is called by SQLite if you have\n" \
"inherited from an underlying VFSFile.  Consequently ensure you pass\n" \
"any unrecognised codes through to your super class.  For example::\n" \
"\n" \
"         def xFileControl(self, op, ptr):\n" \
"             if op==1027:\n" \
"                 process_quick(ptr)\n" \
"             elif op==1028:\n" \
"                 obj=ctypes.py_object.from_address(ptr).value\n" \
"             else:\n" \
"                 # this ensures superclass implementation is called\n" \
"                 return super(MyFile, self).xFileControl(op, ptr)\n" \
" # we understood the op\n" \
"       return True\n" 

#define VFSFile_xFileControl_USAGE "VFSFile.xFileControl(op: int, ptr: int) -> bool"

#define VFSFile_xFileControl_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(op), int)); \
  assert(__builtin_types_compatible_p(typeof(ptr), void *)); \
} while(0)


#define  VFSFile_xFileSize_DOC "xFileSize($self)\n--\n\nVFSFile.xFileSize() -> int\n\n" \
"Return the size of the file in bytes.  Remember that file sizes are\n" \
"64 bit quantities even on 32 bit operating systems.\n" 

#define  VFSFile_xLock_DOC "xLock($self,level)\n--\n\nVFSFile.xLock(level: int) -> None\n\n" \
"Increase the lock to the level specified which is one of the\n" \
"`SQLITE_LOCK <https://sqlite.org/c3ref/c_lock_exclusive.html>`_\n" \
"family of constants. If you can't increase the lock level because\n" \
"someone else has locked it, then raise :exc:`BusyError`.\n" 

#define VFSFile_xLock_USAGE "VFSFile.xLock(level: int) -> None"

#define VFSFile_xLock_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(level), int)); \
} while(0)


#define  VFSFile_xRead_DOC "xRead($self,amount,offset)\n--\n\nVFSFile.xRead(amount: int, offset: int) -> bytes\n\n" \
"Read the specified *amount* of data starting at *offset*. You\n" \
"should make every effort to read all the data requested, or return\n" \
"an error. If you have the file open for non-blocking I/O or if\n" \
"signals happen then it is possible for the underlying operating\n" \
"system to do a partial read. You will need to request the\n" \
"remaining data. Except for empty files SQLite considers short\n" \
"reads to be a fatal error.\n" \
"\n" \
":param amount: Number of bytes to read\n" \
":param offset: Where to start reading. This number may be 64 bit once the database is larger than 2GB.\n" 

#define VFSFile_xRead_USAGE "VFSFile.xRead(amount: int, offset: int) -> bytes"

#define VFSFile_xRead_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(amount), int)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
} while(0)


#define  VFSFile_xSectorSize_DOC "xSectorSize($self)\n--\n\nVFSFile.xSectorSize() -> int\n\n" \
"Return the native underlying sector size. SQLite uses the value\n" \
"returned in determining the default database page size. If you do\n" \
"not implement the function or have an error then 4096 (the SQLite\n" \
"default) is returned.\n" 

#define  VFSFile_xSync_DOC "xSync($self,flags)\n--\n\nVFSFile.xSync(flags: int) -> None\n\n" \
"Ensure data is on the disk platters (ie could survive a power\n" \
"failure immediately after the call returns) with the `sync flags\n" \
"<https://sqlite.org/c3ref/c_sync_dataonly.html>`_ detailing what\n" \
"needs to be synced.  You can sync more than what is requested.\n" 

#define VFSFile_xSync_USAGE "VFSFile.xSync(flags: int) -> None"

#define VFSFile_xSync_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  VFSFile_xTruncate_DOC "xTruncate($self,newsize)\n--\n\nVFSFile.xTruncate(newsize: int) -> None\n\n" \
"Set the file length to *newsize* (which may be more or less than the\n" \
"current length).\n" 

#define VFSFile_xTruncate_USAGE "VFSFile.xTruncate(newsize: int) -> None"

#define VFSFile_xTruncate_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(newsize), long long)); \
} while(0)


#define  VFSFile_xUnlock_DOC "xUnlock($self,level)\n--\n\nVFSFile.xUnlock(level: int) -> None\n\n" \
"Decrease the lock to the level specified which is one of the\n" \
"`SQLITE_LOCK <https://sqlite.org/c3ref/c_lock_exclusive.html>`_\n" \
"family of constants.\n" 

#define VFSFile_xUnlock_USAGE "VFSFile.xUnlock(level: int) -> None"

#define VFSFile_xUnlock_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(level), int)); \
} while(0)


#define  VFSFile_xWrite_DOC "xWrite($self,data,offset)\n--\n\nVFSFile.xWrite(data: bytes, offset: int) -> None\n\n" \
"Write the *data* starting at absolute *offset*. You must write all the data\n" \
"  requested, or return an error. If you have the file open for\n" \
"  non-blocking I/O or if signals happen then it is possible for the\n" \
"  underlying operating system to do a partial write. You will need to\n" \
"  write the remaining data.\n" \
"\n" \
"  :param offset: Where to start writing. This number may be 64 bit once the database is larger than 2GB.\n" \
"\n" \
"URIFilename class\n" \
"=================\n" 

#define VFSFile_xWrite_USAGE "VFSFile.xWrite(data: bytes, offset: int) -> None"

#define VFSFile_xWrite_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(data), Py_buffer)); \
  assert(__builtin_types_compatible_p(typeof(offset), long long)); \
} while(0)


#define  VFS_excepthook_DOC "excepthook($self,etype,evalue,etraceback)\n--\n\nVFS.excepthook(etype: type[BaseException], evalue: BaseException, etraceback: Optional[TracebackType]) -> Any\n\n" \
"Called when there has been an exception in a :class:`VFS` routine.\n" \
"The default implementation passes args to ``sys.excepthook`` and if that\n" \
"fails then ``PyErr_Display``.  The three arguments correspond to\n" \
"what ``sys.exc_info()`` would return.\n" 

#define  VFS_init_DOC "__init__($self,name,base=None,makedefault=False,maxpathname=1024)\n--\n\nVFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024)\n\n" \
"Provides operating system access.  You can get an overview in the\n" \
"`SQLite documentation <https://sqlite.org/c3ref/vfs.html>`_.  To\n" \
"create a VFS your Python class must inherit from :class:`VFS`.\n" \
"\n" \
":param name: The name to register this vfs under.  If the name\n" \
"    already exists then this vfs will replace the prior one of the\n" \
"    same name.  Use :meth:`apsw.vfsnames` to get a list of\n" \
"    registered vfs names.\n" \
"\n" \
":param base: If you would like to inherit behaviour from an already registered vfs then give\n" \
"    their name.  To inherit from the default vfs, use a zero\n" \
"    length string ``\"\"`` as the name.\n" \
"\n" \
":param makedefault: If true then this vfs will be registered as the default, and will be\n" \
"    used by any opens that don't specify a vfs.\n" \
"\n" \
":param maxpathname: The maximum length of database name in bytes when\n" \
"    represented in UTF-8.  If a pathname is passed in longer than\n" \
"    this value then SQLite will not `be able to open it\n" \
"    <https://sqlite.org/src/tktview/c060923a5422590b3734eb92eae0c94934895b68>`__.\n" \
"\n" \
":raises ValueError: If *base* is not :const:`None` and the named vfs is not\n" \
"  currently registered.\n" \
"\n" \
"Calls:\n" \
"  * `sqlite3_vfs_register <https://sqlite.org/c3ref/vfs_find.html>`__\n" \
"  * `sqlite3_vfs_find <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define VFS_init_USAGE "VFS.__init__(name: str, base: Optional[str] = None, makedefault: bool = False, maxpathname: int = 1024)"

#define VFS_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(base), const char *)); \
  assert(base == 0); \
  assert(__builtin_types_compatible_p(typeof(makedefault), int)); \
  assert(makedefault == 0); \
  assert(__builtin_types_compatible_p(typeof(maxpathname), int)); \
  assert(maxpathname == (1024)); \
} while(0)


#define  VFS_unregister_DOC "unregister($self)\n--\n\nVFS.unregister() -> None\n\n" \
"Unregisters the VFS making it unavailable to future database\n" \
"opens. You do not need to call this as the VFS is automatically\n" \
"unregistered by when the VFS has no more references or open\n" \
"databases using it. It is however useful to call if you have made\n" \
"your VFS be the default and wish to immediately make it be\n" \
"unavailable. It is safe to call this routine multiple times.\n" \
"\n" \
"Calls: `sqlite3_vfs_unregister <https://sqlite.org/c3ref/vfs_find.html>`__\n" 

#define  VFS_xAccess_DOC "xAccess($self,pathname,flags)\n--\n\nVFS.xAccess(pathname: str, flags: int) -> bool\n\n" \
"SQLite wants to check access permissions.  Return True or False\n" \
"accordingly.\n" \
"\n" \
":param pathname: File or directory to check\n" \
":param flags: One of the `access flags <https://sqlite.org/c3ref/c_access_exists.html>`_\n" 

#define VFS_xAccess_USAGE "VFS.xAccess(pathname: str, flags: int) -> bool"

#define VFS_xAccess_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(pathname), const char *)); \
  assert(__builtin_types_compatible_p(typeof(flags), int)); \
} while(0)


#define  VFS_xCurrentTime_DOC "xCurrentTime($self)\n--\n\nVFS.xCurrentTime()  -> float\n\n" \
"Return the `Julian Day Number\n" \
"<http://en.wikipedia.org/wiki/Julian_day>`_ as a floating point\n" \
"number where the integer portion is the day and the fractional part\n" \
"is the time. Do not adjust for timezone (ie use `UTC\n" \
"<http://en.wikipedia.org/wiki/Universal_Time>`_).\n" 

#define  VFS_xDelete_DOC "xDelete($self,filename,syncdir)\n--\n\nVFS.xDelete(filename: str, syncdir: bool) -> None\n\n" \
"Delete the named file. If the file is missing then raise an\n" \
":exc:`IOError` exception with extendedresult\n" \
":const:`SQLITE_IOERR_DELETE_NOENT`\n" \
"\n" \
":param filename: File to delete\n" \
"\n" \
":param syncdir: If True then the directory should be synced\n" \
"  ensuring that the file deletion has been recorded on the disk\n" \
"  platters.  ie if there was an immediate power failure after this\n" \
"  call returns, on a reboot the file would still be deleted.\n" 

#define VFS_xDelete_USAGE "VFS.xDelete(filename: str, syncdir: bool) -> None"

#define VFS_xDelete_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
  assert(__builtin_types_compatible_p(typeof(syncdir), int)); \
} while(0)


#define  VFS_xDlClose_DOC "xDlClose($self,handle)\n--\n\nVFS.xDlClose(handle: int) -> None\n\n" \
"Close and unload the library corresponding to the handle you\n" \
"returned from :meth:`~VFS.xDlOpen`.  You can use ctypes to do\n" \
"this::\n" \
"\n" \
"  def xDlClose(handle):\n" \
"     # Note leading underscore in _ctypes\n" \
"     _ctypes.dlclose(handle)       # Linux/Mac/Unix\n" \
"     _ctypes.FreeLibrary(handle)   # Windows\n" 

#define VFS_xDlClose_USAGE "VFS.xDlClose(handle: int) -> None"

#define VFS_xDlClose_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(handle), void *)); \
} while(0)


#define  VFS_xDlError_DOC "xDlError($self)\n--\n\nVFS.xDlError() -> str\n\n" \
"Return an error string describing the last error of\n" \
":meth:`~VFS.xDlOpen` or :meth:`~VFS.xDlSym` (ie they returned\n" \
"zero/NULL). If you do not supply this routine then SQLite provides\n" \
"a generic message. To implement this method, catch exceptions in\n" \
":meth:`~VFS.xDlOpen` or :meth:`~VFS.xDlSym`, turn them into\n" \
"strings, save them, and return them in this routine.  If you have\n" \
"an error in this routine or return None then SQLite's generic\n" \
"message will be used.\n" 

#define  VFS_xDlOpen_DOC "xDlOpen($self,filename)\n--\n\nVFS.xDlOpen(filename: str) -> int\n\n" \
"Load the shared library. You should return a number which will be\n" \
"treated as a void pointer at the C level. On error you should\n" \
"return 0 (NULL). The number is passed as is to\n" \
":meth:`~VFS.xDlSym`/:meth:`~VFS.xDlClose` so it can represent\n" \
"anything that is convenient for you (eg an index into an\n" \
"array). You can use ctypes to load a library::\n" \
"\n" \
"  def xDlOpen(name):\n" \
"     return ctypes.cdll.LoadLibrary(name)._handle\n" 

#define VFS_xDlOpen_USAGE "VFS.xDlOpen(filename: str) -> int"

#define VFS_xDlOpen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(filename), const char *)); \
} while(0)


#define  VFS_xDlSym_DOC "xDlSym($self,handle,symbol)\n--\n\nVFS.xDlSym(handle: int, symbol: str) -> int\n\n" \
"Returns the address of the named symbol which will be called by\n" \
"SQLite. On error you should return 0 (NULL). You can use ctypes::\n" \
"\n" \
"  def xDlSym(ptr, name):\n" \
"     return _ctypes.dlsym (ptr, name)  # Linux/Unix/Mac etc (note leading underscore)\n" \
"     return ctypes.win32.kernel32.GetProcAddress (ptr, name)  # Windows\n" \
"\n" \
":param handle: The value returned from an earlier :meth:`~VFS.xDlOpen` call\n" \
":param symbol: A string\n" 

#define VFS_xDlSym_USAGE "VFS.xDlSym(handle: int, symbol: str) -> int"

#define VFS_xDlSym_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(handle), void *)); \
  assert(__builtin_types_compatible_p(typeof(symbol), const char *)); \
} while(0)


#define  VFS_xFullPathname_DOC "xFullPathname($self,name)\n--\n\nVFS.xFullPathname(name: str) -> str\n\n" \
"Return the absolute pathname for name.  You can use ``os.path.abspath`` to do this.\n" 

#define VFS_xFullPathname_USAGE "VFS.xFullPathname(name: str) -> str"

#define VFS_xFullPathname_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xGetLastError_DOC "xGetLastError($self)\n--\n\nVFS.xGetLastError() -> Tuple[int, str]\n\n" \
"This method is to return an integer error code and (optional) text describing\n" \
"the last error that happened in this thread.\n" \
"\n" \
".. note:: SQLite 3.12 changed the semantics in an incompatible way from\n" \
"     earlier versions.  You will need to rewrite earlier implementations.\n" 

#define  VFS_xGetSystemCall_DOC "xGetSystemCall($self,name)\n--\n\nVFS.xGetSystemCall(name: str) -> Optional[int]\n\n" \
"Returns a pointer for the current method implementing the named\n" \
"system call.  Return None if the call does not exist.\n" 

#define VFS_xGetSystemCall_USAGE "VFS.xGetSystemCall(name: str) -> Optional[int]"

#define VFS_xGetSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xNextSystemCall_DOC "xNextSystemCall($self,name)\n--\n\nVFS.xNextSystemCall(name: Optional[str]) -> Optional[str]\n\n" \
"This method is repeatedly called to iterate over all of the system\n" \
"calls in the vfs.  When called with None you should return the\n" \
"name of the first system call.  In subsequent calls return the\n" \
"name after the one passed in.  If name is the last system call\n" \
"then return None.\n" \
"\n" \
".. note::\n" \
"\n" \
"  Because of internal SQLite implementation semantics memory will\n" \
"  be leaked on each call to this function.  Consequently you\n" \
"  should build up the list of call names once rather than\n" \
"  repeatedly doing it.\n" 

#define VFS_xNextSystemCall_USAGE "VFS.xNextSystemCall(name: Optional[str]) -> Optional[str]"

#define VFS_xNextSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
} while(0)


#define  VFS_xOpen_DOC "xOpen($self,name,flags)\n--\n\nVFS.xOpen(name: Optional[Union[str,URIFilename]], flags: List[int,int]) -> VFSFile\n\n" \
"This method should return a new file object based on name.  You\n" \
"can return a :class:`VFSFile` from a completely different VFS.\n" \
"\n" \
":param name: File to open.  Note that *name* may be :const:`None` in which\n" \
"    case you should open a temporary file with a name of your\n" \
"    choosing.  May be an instance of :class:`URIFilename`.\n" \
"\n" \
":param flags: A list of two integers ``[inputflags,\n" \
"  outputflags]``.  Each integer is one or more of the `open flags\n" \
"  <https://sqlite.org/c3ref/c_open_autoproxy.html>`_ binary orred\n" \
"  together.  The ``inputflags`` tells you what SQLite wants.  For\n" \
"  example :const:`SQLITE_OPEN_DELETEONCLOSE` means the file should\n" \
"  be automatically deleted when closed.  The ``outputflags``\n" \
"  describes how you actually did open the file.  For example if you\n" \
"  opened it read only then :const:`SQLITE_OPEN_READONLY` should be\n" \
"  set.\n" 

#define VFS_xOpen_USAGE "VFS.xOpen(name: Optional[Union[str,URIFilename]], flags: List[int,int]) -> VFSFile"

#define VFS_xOpen_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), PyObject *)); \
  assert(__builtin_types_compatible_p(typeof(flags), PyObject *)); \
} while(0)


#define  VFS_xRandomness_DOC "xRandomness($self,numbytes)\n--\n\nVFS.xRandomness(numbytes: int) -> bytes\n\n" \
"This method is called once when SQLite needs to seed the random\n" \
"number generator. It is called on the default VFS only. It is not\n" \
"called again, even across :meth:`apsw.shutdown` calls.  You can\n" \
"return less than the number of bytes requested including None. If\n" \
"you return more then the surplus is ignored.\n" 

#define VFS_xRandomness_USAGE "VFS.xRandomness(numbytes: int) -> bytes"

#define VFS_xRandomness_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(numbytes), int)); \
} while(0)


#define  VFS_xSetSystemCall_DOC "xSetSystemCall($self,name,pointer)\n--\n\nVFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool\n\n" \
"Change a system call used by the VFS.  This is useful for testing\n" \
"and some other scenarios such as sandboxing.\n" \
"\n" \
":param name: The string name of the system call\n" \
"\n" \
":param pointer: A pointer provided as an int.  There is no\n" \
"  reference counting or other memory tracking of the pointer.  If\n" \
"  you provide one you need to ensure it is around for the lifetime\n" \
"  of this and any other related VFS.\n" \
"\n" \
"Raise an exception to return an error.  If the system call does\n" \
"not exist then raise :exc:`NotFoundError`.\n" \
"\n" \
"If `name` is None, then all systemcalls are reset to their defaults.  This\n" \
"behaviour is not documented.\n" \
"\n" \
":returns: True if the system call was set.  False if the system\n" \
"  call is not known.\n" 

#define VFS_xSetSystemCall_USAGE "VFS.xSetSystemCall(name: Optional[str], pointer: int) -> bool"

#define VFS_xSetSystemCall_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(name), const char *)); \
  assert(__builtin_types_compatible_p(typeof(pointer), void *)); \
} while(0)


#define  VFS_xSleep_DOC "xSleep($self,microseconds)\n--\n\nVFS.xSleep(microseconds: int) -> int\n\n" \
"Pause execution of the thread for at least the specified number of\n" \
"    microseconds (millionths of a second).  This routine is typically called from the busy handler.\n" \
"\n" \
"    :returns: How many microseconds you actually requested the\n" \
"      operating system to sleep for. For example if your operating\n" \
"      system sleep call only takes seconds then you would have to have\n" \
"      rounded the microseconds number up to the nearest second and\n" \
"      should return that rounded up value.\n" \
"\n" \
"VFSFile class\n" \
"=============\n" 

#define VFS_xSleep_USAGE "VFS.xSleep(microseconds: int) -> int"

#define VFS_xSleep_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(microseconds), int)); \
} while(0)


#define  Zeroblob_init_DOC "__init__($self,size)\n--\n\nzeroblob.__init__(size: int)\n\n" \
"If you want to insert a blob into a row, you previously needed to\n" \
"supply the entire blob in one go.  To read just one byte also\n" \
"required retrieving the blob in its entirety. For example to insert\n" \
"a 100MB file you would have done::\n" \
"\n" \
"   largedata=open(\"largefile\", \"rb\").read()\n" \
"   cur.execute(\"insert into foo values(?)\", (largedata,))\n" \
"\n" \
"SQLite 3.5 allowed for incremental Blob I/O so you can read and\n" \
"write blobs in small amounts.  You cannot change the size of a blob\n" \
"so you need to reserve space which you do through zeroblob which\n" \
"creates a blob of the specified size but full of zero bytes.  For\n" \
"example you would reserve space for your 100MB one of these two\n" \
"ways::\n" \
"\n" \
"  cur.execute(\"insert into foo values(zeroblob(100000000))\")\n" \
"  cur.execute(\"insert into foo values(?),\n" \
"               (apsw.zeroblob(100000000),))\n" \
"\n" \
"This class is used for the second way.  Once a blob exists in the\n" \
"database, you then use the :class:`blob` class to read and write its\n" \
"contents.\n" 

#define Zeroblob_init_USAGE "zeroblob.__init__(size: int)"

#define Zeroblob_init_CHECK do { \
  assert(__builtin_types_compatible_p(typeof(size), int)); \
} while(0)


#define  Zeroblob_length_DOC "length($self)\n--\n\nzeroblob.length() -> int\n\n" \
"Size of zero blob in bytes.\n" \
"\n" \
"Blob class\n" \
"==========\n" 

